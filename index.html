<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Träningsplan – dra in alla objekt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 16px;
      background: #111;
      color: #f5f5f5;
      box-sizing: border-box;
      min-height: 150vh;

      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    h1 {
      font-size: 1.2rem;
      margin-bottom: 8px;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .controls-row2 {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    .controls-row3 {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    input[type="checkbox"] {
      width: 14px;
      height: 14px;
    }

    button {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      background: #2e8b57;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }

    button:active {
      transform: scale(0.97);
    }

    .wrapper {
      max-width: 600px;
      margin: 0 auto;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 0.8rem;
      align-items: center;
    }

    .palette-label {
      margin-right: 4px;
    }

    .palette-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
    }

    .pitch-wrapper {
      position: relative;
      -webkit-user-select: none;
      user-select: none;
    }

    .pitch {
      position: relative;
      width: 100%;
      background: #1f7a3c;
      border-radius: 12px;
      border: 2px solid #fff;
      overflow: hidden;
      touch-action: none;
      pointer-events: none;
    }

    .pitch.show-lines::before,
    .pitch.show-lines::after {
      content: "";
      position: absolute;
      pointer-events: none;
    }

    .pitch.show-lines::before {
      left: 0;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      height: 0;
      border-top: 2px solid #fff;
      opacity: 0.7;
    }

    .pitch.show-lines::after {
      width: 30%;
      height: 0;
      padding-top: 30%;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.5);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .pitch-resize-handle {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -14px;
      width: 80px;
      height: 14px;
      border-radius: 8px;
      background: #333;
      border: 1px solid #777;
      color: #ccc;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 15;
      cursor: ns-resize;
      touch-action: none;
      pointer-events: auto;
    }

    .player {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 0 0 2px #fff;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .player.blue {
      background: #007bff;
    }

    .player.red {
      background: #e53935;
    }

    .player.dragging {
      opacity: 0.8;
      cursor: grabbing;
    }

    .player.recording {
      box-shadow: 0 0 0 2px #ffd54f, 0 0 8px #ffeb3b;
    }

    .goal {
      position: absolute;
      /* lite bredare mål */
      width: 60px;
      height: 18px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.2);
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 10px;
      font-weight: 600;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
      transform-origin: center center;
    }

    .goal-label {
      pointer-events: none;
    }

    .cone-icon,
    .ball-icon,
    .player-blue-icon,
    .player-red-icon,
    .goal-icon {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .cone-icon {
      background: #ff9800;
      box-shadow: 0 0 0 2px #fff;
      color: #111;
    }

    .ball-icon {
      background: #ffffff;
      box-shadow: 0 0 0 2px #000;
      color: #000;
    }

    .player-blue-icon {
      background: #007bff;
      box-shadow: 0 0 0 2px #fff;
      color: #fff;
    }

    .player-red-icon {
      background: #e53935;
      box-shadow: 0 0 0 2px #fff;
      color: #fff;
    }

    .goal-icon {
      border-radius: 6px;
      width: 40px;
      height: 18px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-size: 10px;
    }

    .cone {
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ff9800;
      box-shadow: 0 0 0 2px #fff;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .ball {
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ffffff;
      box-shadow: 0 0 0 2px #000;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .selected {
      box-shadow: 0 0 0 2px #ffd54f, 0 0 8px #ffeb3b;
    }

    .overlay-svg {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }

    .run-path {
      fill: none;
      stroke: #ffeb3b;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .ball-trail {
      fill: none;
      stroke: #ffffff;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    pre {
      margin-top: 16px;
      font-size: 0.75rem;
      background: #000;
      padding: 8px;
      border-radius: 6px;
      max-height: 180px;
      overflow: auto;

      -webkit-user-select: text;
      user-select: text;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Plan – dra in spelare, mål, konor & bollar</h1>

    <div class="controls-row2">
      <label>
        <input type="checkbox" id="showLines" checked />
        Visa mittlinje & cirkel
      </label>
      <span id="ratioDisplay">Ratio: 3:2</span>
      <button id="undoBtn">Ångra</button>
    </div>

    <div class="palette">
      <span class="palette-label">Dra in på planen:</span>

      <div class="palette-item">
        <div id="playerBlueSource" class="player-blue-icon">B</div>
        <span>Blå</span>
      </div>

      <div class="palette-item">
        <div id="playerRedSource" class="player-red-icon">R</div>
        <span>Röd</span>
      </div>

      <div class="palette-item">
        <div id="goalSource" class="goal-icon">Mål</div>
        <span>Mål</span>
      </div>

      <div class="palette-item">
        <div id="coneSource" class="cone-icon">K</div>
        <span>Kona</span>
      </div>

      <div class="palette-item">
        <div id="ballSource" class="ball-icon">B</div>
        <span>Boll</span>
      </div>
    </div>

    <div class="pitch-wrapper">
      <div id="pitch" class="pitch show-lines"></div>
      <svg id="overlaySvg" class="overlay-svg"></svg>
      <div id="resizeHandle" class="pitch-resize-handle">Dra för längd</div>
    </div>

    <pre id="stateOutput"></pre>
  </div>

  <script>
    const pitch = document.getElementById("pitch");
    const resizeHandle = document.getElementById("resizeHandle");
    const stateOutput = document.getElementById("stateOutput");
    const showLinesCheckbox = document.getElementById("showLines");
    const ratioDisplay = document.getElementById("ratioDisplay");
    const undoBtn = document.getElementById("undoBtn");
    const overlaySvg = document.getElementById("overlaySvg");

    const playerBlueSource = document.getElementById("playerBlueSource");
    const playerRedSource = document.getElementById("playerRedSource");
    const goalSource = document.getElementById("goalSource");
    const coneSource = document.getElementById("coneSource");
    const ballSource = document.getElementById("ballSource");

    let playersState = []; // {id, team, xRel, yRel}
    let goalsState = [];   // {id, xRel, yRel, rotationDeg}
    let conesState = [];   // {id, xRel, yRel}
    let ballsState = [];   // {id, xRel, yRel}
    let dragInfo = null;

    let playerBlueCounter = 0;
    let playerRedCounter = 0;
    let goalCounter = 0;
    let coneCounter = 0;
    let ballCounter = 0;

    const PLAYER_RADIUS = 16;
    const BALL_RADIUS = 11;
    const MIN_DIST = PLAYER_RADIUS * 2 * 1.1;
    const MAX_RELAX_STEPS = 20;

    // Undo
    let undoStack = [];
    const UNDO_LIMIT = 10;

    // Drill-sekvenser (spelare)
    let drillSequences = [];
    let recordingSequence = null;
    let recordingActorId = null;
    let recordingStartTime = 0;
    let longPressTimer = null;
    let longPressThreshold = 500;
    let pointerDownTime = 0;
    let pointerMovedTooMuch = false;
    let pointerDownPos = null;

    // Boll-ägande och trail
    let ballOwnerId = null;
    let ballTrailPoints = [];

    function pushUndoState() {
      const snapshot = JSON.parse(JSON.stringify({
        playersState,
        goalsState,
        conesState,
        ballsState,
        drillSequences,
        ballOwnerId,
        ballTrailPoints
      }));
      undoStack.push(snapshot);
      if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    }

    function restoreStateFromSnapshot(snapshot) {
      playersState = JSON.parse(JSON.stringify(snapshot.playersState));
      goalsState = JSON.parse(JSON.stringify(snapshot.goalsState));
      conesState = JSON.parse(JSON.stringify(snapshot.conesState));
      ballsState = JSON.parse(JSON.stringify(snapshot.ballsState));
      drillSequences = JSON.parse(JSON.stringify(snapshot.drillSequences));
      ballOwnerId = snapshot.ballOwnerId || null;
      ballTrailPoints = snapshot.ballTrailPoints || [];

      [...pitch.querySelectorAll(".player")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".goal")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".cone")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".ball")].forEach(el => el.remove());
      while (overlaySvg.firstChild) overlaySvg.removeChild(overlaySvg.firstChild);

      const pitchRect = pitch.getBoundingClientRect();

      for (const p of playersState) {
        const el = document.createElement("div");
        el.className = "player " + p.team;
        el.dataset.id = p.id;
        el.dataset.team = p.team;
        el.textContent = p.team === "blue" ? p.id.replace("B", "") : p.id.replace("R", "");
        const x = p.xRel * pitchRect.width;
        const y = p.yRel * pitchRect.height;
        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";
        pitch.appendChild(el);
        setupPlayerDrag(el);
        setupClickHandlers(el);
      }

      renderGoals();
      renderCones();
      renderBalls();
      renderAllSequencesPaths();
      renderBallTrail();
      renderState();
    }

    function initPitchHeight() {
      const rect = pitch.getBoundingClientRect();
      const targetHeight = rect.width * (2 / 3);
      pitch.style.height = targetHeight + "px";
      updateRatioDisplay();
    }

    function updateRatioDisplay() {
      const rect = pitch.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      const ratio = (w / h).toFixed(2);
      ratioDisplay.textContent = "Ratio: " + ratio + " : 1";
    }

    function applyLinesClass() {
      if (showLinesCheckbox.checked) pitch.classList.add("show-lines");
      else pitch.classList.remove("show-lines");
    }

    function clearSelectionHighlight() {
      [...pitch.querySelectorAll(".player, .ball, .cone, .goal")].forEach(el => {
        el.classList.remove("selected");
      });
    }

    // --- PROTOTYPISK CLICK-HANTERING: trippel = ta bort, dubbel på mål = rotera ---
    function setupClickHandlers(el) {
      let clickCount = 0;
      let clickTimer = null;

      el.addEventListener("click", (e) => {
        if (e.detail === 3) {
          // trippel-klick → ta bort
          handleTripleClick(el);
          return;
        }

        clickCount++;
        if (clickTimer) clearTimeout(clickTimer);

        clickTimer = setTimeout(() => {
          if (clickCount === 2) {
            if (el.classList.contains("goal")) {
              // dubbelklick på mål → rotera
              rotateGoal(el);
            }
          }
          clickCount = 0;
          clickTimer = null;
        }, 250);
      });
    }

    function handleTripleClick(el) {
      const id = el.dataset.id;
      const type = getElementType(el);

      pushUndoState();

      if (type === "player") {
        const idx = playersState.findIndex(p => p.id === id);
        if (idx !== -1) playersState.splice(idx, 1);
      } else if (type === "goal") {
        const idx = goalsState.findIndex(g => g.id === id);
        if (idx !== -1) goalsState.splice(idx, 1);
      } else if (type === "cone") {
        const idx = conesState.findIndex(c => c.id === id);
        if (idx !== -1) conesState.splice(idx, 1);
      } else if (type === "ball") {
        const idx = ballsState.findIndex(b => b.id === id);
        if (idx !== -1) ballsState.splice(idx, 1);
      }

      el.remove();
      renderState();
    }

    function getElementType(el) {
      if (el.classList.contains("player")) return "player";
      if (el.classList.contains("goal")) return "goal";
      if (el.classList.contains("cone")) return "cone";
      if (el.classList.contains("ball")) return "ball";
      return null;
    }

    function rotateGoal(el) {
      const id = el.dataset.id;
      const gState = goalsState.find(g => g.id === id);
      if (!gState) return;
      pushUndoState();
      gState.rotationDeg = (gState.rotationDeg + 90) % 360;
      el.style.transform = `translate(-50%, -50%) rotate(${gState.rotationDeg}deg)`;
      renderState();
    }

    // --- DRAG FÖR SPELARE ---

    function setupPlayerDrag(el) {
      el.addEventListener("pointerdown", onPointerDownPlayer);
    }

    function onPointerDownPlayer(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      const target = e.currentTarget;
      const id = target.dataset.id;

      target.setPointerCapture(e.pointerId);
      target.classList.add("dragging");

      const rect = target.getBoundingClientRect();
      const pitchRect = pitch.getBoundingClientRect();

      const centerX = rect.left - pitchRect.left + PLAYER_RADIUS;
      const centerY = rect.top - pitchRect.top + PLAYER_RADIUS;

      dragInfo = {
        type: "player",
        id,
        el: target,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect,
        pointerId: e.pointerId,
        prevX: centerX,
        prevY: centerY,
        lastDirX: 0,
        lastDirY: -1
      };

      pointerDownTime = performance.now();
      pointerMovedTooMuch = false;
      pointerDownPos = { x: e.clientX, y: e.clientY };
      longPressTimer = setTimeout(() => {
        startRecordingForActor(id, target, pitchRect, e);
      }, longPressThreshold);

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function cancelLongPressTimer() {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }

    function startRecordingForActor(actorId, el, pitchRect, e) {
      recordingActorId = actorId;
      recordingStartTime = performance.now();
      const seqId = "SEQ" + (drillSequences.length + 1);
      const kind = "run";
      recordingSequence = {
        id: seqId,
        actorId,
        kind,
        startAt: 0,
        points: [],
        svgId: seqId
      };
      drillSequences.push(recordingSequence);
      el.classList.add("recording");

      const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      polyline.setAttribute("id", seqId);
      polyline.setAttribute("class", "run-path");
      polyline.setAttribute("points", "");
      overlaySvg.appendChild(polyline);

      const x = e.clientX - pitchRect.left;
      const y = e.clientY - pitchRect.top;
      addRecordingPoint(x, y);
    }

    function addRecordingPoint(x, y) {
      if (!recordingSequence) return;
      const pitchRect = pitch.getBoundingClientRect();
      const t = (performance.now() - recordingStartTime) / 1000;
      const xRel = x / pitchRect.width;
      const yRel = y / pitchRect.height;
      recordingSequence.points.push({ t, xRel, yRel });

      const polyline = document.getElementById(recordingSequence.svgId);
      if (polyline) {
        const pts = recordingSequence.points
          .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
          .join(" ");
        polyline.setAttribute("points", pts);
      }
    }

    function stopRecording() {
      if (!recordingSequence) return;
      const actorEl = [...pitch.querySelectorAll(".player")].find(el => el.dataset.id === recordingActorId);
      if (actorEl) actorEl.classList.remove("recording");
      if (recordingSequence.points.length > 0) {
        const firstT = recordingSequence.points[0].t;
        const lastT = recordingSequence.points[recordingSequence.points.length - 1].t;
        recordingSequence.duration = lastT - firstT;
      } else {
        recordingSequence.duration = 0;
      }
      recordingSequence = null;
      recordingActorId = null;
    }

    // --- DRAG FÖR MÅL/CONES/BOLL ---

    function setupGoalDrag(el) {
      el.addEventListener("pointerdown", (e) => {
        clearSelectionHighlight();
        el.classList.add("selected");

        const target = el;
        const id = target.dataset.id;

        target.setPointerCapture(e.pointerId);
        target.classList.add("dragging");

        const rect = target.getBoundingClientRect();
        const pitchRect = pitch.getBoundingClientRect();

        dragInfo = {
          type: "goal",
          id,
          el: target,
          offsetX: e.clientX - rect.left,
          offsetY: e.clientY - rect.top,
          pitchRect
        };

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", onPointerUp);
      });
      setupClickHandlers(el);
    }

    function setupConeDrag(el) {
      el.addEventListener("pointerdown", onPointerDownCone);
      setupClickHandlers(el);
    }

    function setupBallDrag(el) {
      el.addEventListener("pointerdown", onPointerDownBall);
      setupClickHandlers(el);
    }

    function onPointerDownCone(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      const pitchRect = pitch.getBoundingClientRect();
      const source = e.currentTarget;

      if (source === coneSource) {
        pushUndoState();
        coneCounter++;
        const id = "C" + coneCounter;
        const coneEl = document.createElement("div");
        coneEl.className = "cone";
        coneEl.dataset.id = id;

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(coneEl);
        const halfW = coneEl.offsetWidth / 2;
        const halfH = coneEl.offsetHeight / 2;
        coneEl.style.left = (x - halfW) + "px";
        coneEl.style.top = (y - halfH) + "px";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        conesState.push({ id, xRel, yRel });

        setupConeDrag(coneEl);

        startConeDrag(e, coneEl, id, pitchRect);
      } else {
        const id = source.dataset.id;
        startConeDrag(e, source, id, pitchRect);
      }
    }

    function onPointerDownBall(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      ballOwnerId = null;

      const pitchRect = pitch.getBoundingClientRect();
      const source = e.currentTarget;

      if (source === ballSource) {
        pushUndoState();
        ballCounter++;
        const id = "BAll" + ballCounter;
        const ballEl = document.createElement("div");
        ballEl.className = "ball";
        ballEl.dataset.id = id;

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(ballEl);
        const halfW = ballEl.offsetWidth / 2;
        const halfH = ballEl.offsetHeight / 2;
        ballEl.style.left = (x - halfW) + "px";
        ballEl.style.top = (y - halfH) + "px";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        ballsState.push({ id, xRel, yRel });

        setupBallDrag(ballEl);

        startBallDrag(e, ballEl, id, pitchRect);
      } else {
        const id = source.dataset.id;
        startBallDrag(e, source, id, pitchRect);
      }

      ballTrailPoints = [];
      renderBallTrail();
    }

    function startConeDrag(e, el, id, pitchRect) {
      e.stopPropagation();
      el.setPointerCapture(e.pointerId);
      el.classList.add("dragging");

      const rect = el.getBoundingClientRect();

      dragInfo = {
        type: "cone",
        id,
        el,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect
      };

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function startBallDrag(e, el, id, pitchRect) {
      e.stopPropagation();
      el.setPointerCapture(e.pointerId);
      el.classList.add("dragging");

      const rect = el.getBoundingClientRect();
      const centerX = rect.left - pitchRect.left + BALL_RADIUS;
      const centerY = rect.top - pitchRect.top + BALL_RADIUS;

      dragInfo = {
        type: "ball",
        id,
        el,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect,
        prevX: centerX,
        prevY: centerY
      };

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function addBallTrailPoint(x, y) {
      const pitchRect = pitch.getBoundingClientRect();
      const xRel = x / pitchRect.width;
      const yRel = y / pitchRect.height;
      const last = ballTrailPoints[ballTrailPoints.length - 1];
      if (last) {
        const lastX = last.xRel * pitchRect.width;
        const lastY = last.yRel * pitchRect.height;
        const dist = Math.hypot(x - lastX, y - lastY);
        if (dist < 3) return;
      }
      ballTrailPoints.push({ xRel, yRel });
      renderBallTrail();
    }

    function renderBallTrail() {
      const old = document.getElementById("ballTrail");
      if (old) overlaySvg.removeChild(old);
      if (!ballTrailPoints.length) return;

      const pitchRect = pitch.getBoundingClientRect();
      const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      poly.setAttribute("id", "ballTrail");
      poly.setAttribute("class", "ball-trail");
      const pts = ballTrailPoints
        .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
        .join(" ");
      poly.setAttribute("points", pts);
      overlaySvg.appendChild(poly);
    }

    // --- DRAG FÖR BLÅ/RÖD SPELARE & MÅL KÄLLOR ---

    function setupPlayerSourceDrag(sourceEl, team) {
      sourceEl.addEventListener("pointerdown", (e) => {
        clearSelectionHighlight();
        const pitchRect = pitch.getBoundingClientRect();

        if (sourceEl === e.currentTarget) {
          pushUndoState();
          const isBlue = team === "blue";
          if (isBlue) playerBlueCounter++;
          else playerRedCounter++;
          const id = isBlue ? "B" + playerBlueCounter : "R" + playerRedCounter;

          const playerEl = document.createElement("div");
          playerEl.className = "player " + team;
          playerEl.dataset.id = id;
          playerEl.dataset.team = team;
          playerEl.textContent = isBlue ? playerBlueCounter : playerRedCounter;

          let x = e.clientX - pitchRect.left;
          let y = e.clientY - pitchRect.top;
          x = Math.max(0, Math.min(pitchRect.width, x));
          y = Math.max(0, Math.min(pitchRect.height, y));

          pitch.appendChild(playerEl);
          const half = PLAYER_RADIUS;
          playerEl.style.left = (x - half) + "px";
          playerEl.style.top = (y - half) + "px";

          const xRel = x / pitchRect.width;
          const yRel = y / pitchRect.height;
          playersState.push({ id, team, xRel, yRel });

          setupPlayerDrag(playerEl);
          setupClickHandlers(playerEl);
          playerEl.classList.add("selected");

          onPointerDownPlayer(new PointerEvent("pointerdown", {
            clientX: e.clientX,
            clientY: e.clientY,
            pointerId: e.pointerId,
            bubbles: true
          }));
        }
      });
    }

    function setupGoalSourceDrag(sourceEl) {
      sourceEl.addEventListener("pointerdown", (e) => {
        clearSelectionHighlight();
        const pitchRect = pitch.getBoundingClientRect();

        if (sourceEl === e.currentTarget) {
          pushUndoState();
          goalCounter++;
          const id = "G" + goalCounter;

          const goalEl = document.createElement("div");
          goalEl.className = "goal";
          goalEl.dataset.id = id;

          const label = document.createElement("span");
          label.className = "goal-label";
          label.textContent = "Mål";
          goalEl.appendChild(label);

          let x = e.clientX - pitchRect.left;
          let y = e.clientY - pitchRect.top;
          x = Math.max(0, Math.min(pitchRect.width, x));
          y = Math.max(0, Math.min(pitchRect.height, y));

          pitch.appendChild(goalEl);
          goalEl.style.left = x + "px";
          goalEl.style.top = y + "px";
          goalEl.style.transform = "translate(-50%, -50%) rotate(0deg)";

          const xRel = x / pitchRect.width;
          const yRel = y / pitchRect.height;
          goalsState.push({ id, xRel, yRel, rotationDeg: 0 });

          setupGoalDrag(goalEl);

          goalEl.classList.add("selected");

          goalEl.dispatchEvent(new PointerEvent("pointerdown", {
            clientX: e.clientX,
            clientY: e.clientY,
            pointerId: e.pointerId,
            bubbles: true
          }));
        }
      });
    }

    function onPointerMove(e) {
      if (!dragInfo) return;

      const moveDist = pointerDownPos
        ? Math.hypot(e.clientX - pointerDownPos.x, e.clientY - pointerDownPos.y)
        : 0;
      if (moveDist > 10) {
        pointerMovedTooMuch = true;
      }

      if (dragInfo.type === "player") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + PLAYER_RADIUS;
        let y = e.clientY - pitchRect.top - offsetY + PLAYER_RADIUS;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        const prevX = dragInfo.prevX;
        const prevY = dragInfo.prevY;
        const dx = x - prevX;
        const dy = y - prevY;

        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";

        const pState = playersState.find(p => p.id === id);
        if (pState) {
          pState.xRel = x / pitchRect.width;
          pState.yRel = y / pitchRect.height;
        }

        let dirX = dragInfo.lastDirX;
        let dirY = dragInfo.lastDirY;
        const len = Math.hypot(dx, dy);
        if (len > 0.1) {
          const newX = dx / len;
          const newY = dy / len;
          const alpha = 0.3;
          dirX = dirX * (1 - alpha) + newX * alpha;
          dirY = dirY * (1 - alpha) + newY * alpha;
          const dlen = Math.hypot(dirX, dirY);
          if (dlen > 0) {
            dirX /= dlen;
            dirY /= dlen;
          }
          dragInfo.lastDirX = dirX;
          dragInfo.lastDirY = dirY;
        }

        if (ballOwnerId === id) {
          const ballEl = pitch.querySelector(".ball");
          if (ballEl) {
            const offset = PLAYER_RADIUS + BALL_RADIUS;
            let ballX = x + dirX * offset;
            let ballY = y + dirY * offset;

            ballX = Math.max(BALL_RADIUS, Math.min(pitchRect.width - BALL_RADIUS, ballX));
            ballY = Math.max(BALL_RADIUS, Math.min(pitchRect.height - BALL_RADIUS, ballY));

            ballEl.style.left = (ballX - BALL_RADIUS) + "px";
            ballEl.style.top = (ballY - BALL_RADIUS) + "px";

            const bState = ballsState[0];
            if (bState) {
              bState.xRel = ballX / pitchRect.width;
              bState.yRel = ballY / pitchRect.height;
            }

            addBallTrailPoint(ballX, ballY);
          }
        }

        dragInfo.prevX = x;
        dragInfo.prevY = y;

        if (recordingActorId === id && recordingSequence) {
          addRecordingPoint(x, y);
        }

        if (pointerMovedTooMuch) cancelLongPressTimer();

      } else if (dragInfo.type === "goal") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + el.offsetWidth / 2;
        let y = e.clientY - pitchRect.top - offsetY + el.offsetHeight / 2;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        el.style.left = x + "px";
        el.style.top = y + "px";

        const gState = goalsState.find(g => g.id === id);
        if (gState) {
          gState.xRel = x / pitchRect.width;
          gState.yRel = y / pitchRect.height;
        }
      } else if (dragInfo.type === "cone") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + el.offsetWidth / 2;
        let y = e.clientY - pitchRect.top - offsetY + el.offsetHeight / 2;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        el.style.left = (x - el.offsetWidth / 2) + "px";
        el.style.top = (y - el.offsetHeight / 2) + "px";

        const cState = conesState.find(c => c.id === id);
        if (cState) {
          cState.xRel = x / pitchRect.width;
          cState.yRel = y / pitchRect.height;
        }
      } else if (dragInfo.type === "ball") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + BALL_RADIUS;
        let y = e.clientY - pitchRect.top - offsetY + BALL_RADIUS;

        x = Math.max(BALL_RADIUS, Math.min(pitchRect.width - BALL_RADIUS, x));
        y = Math.max(BALL_RADIUS, Math.min(pitchRect.height - BALL_RADIUS, y));

        el.style.left = (x - BALL_RADIUS) + "px";
        el.style.top = (y - BALL_RADIUS) + "px";

        const bState = ballsState.find(b => b.id === id);
        if (bState) {
          bState.xRel = x / pitchRect.width;
          bState.yRel = y / pitchRect.height;
        }

        addBallTrailPoint(x, y);

      } else if (dragInfo.type === "resize") {
        const { startY, startHeight } = dragInfo;
        const dy = e.clientY - startY;
        let newHeight = startHeight + dy;

        const rect = pitch.getBoundingClientRect();
        const minHeight = rect.width * 0.4;
        const maxHeight = rect.width * 1.6;

        newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
        pitch.style.height = newHeight + "px";

        updateRatioDisplay();
      }
    }

    function onPointerUp(e) {
      if (!dragInfo) return;

      if (dragInfo.type === "player") {
        const { pitchRect, id, el } = dragInfo;
        el.classList.remove("dragging");
        el.releasePointerCapture(e.pointerId);

        cancelLongPressTimer();
        stopRecording();

        resolveOverlapsForPlayer(id, pitchRect);

        const ballEl = pitch.querySelector(".ball");
        if (ballEl) {
          const ballRect = ballEl.getBoundingClientRect();
          const playerRect = el.getBoundingClientRect();
          const pRect = pitch.getBoundingClientRect();

          const px = playerRect.left - pRect.left + PLAYER_RADIUS;
          const py = playerRect.top - pRect.top + PLAYER_RADIUS;
          const bx = ballRect.left - pRect.left + BALL_RADIUS;
          const by = ballRect.top - pRect.top + BALL_RADIUS;

          const dist = Math.hypot(px - bx, py - by);
          if (dist < PLAYER_RADIUS + BALL_RADIUS + 2) {
            ballOwnerId = id;

            const dirX = dragInfo.lastDirX || 0;
            const dirY = dragInfo.lastDirY || -1;
            const offset = PLAYER_RADIUS + BALL_RADIUS;
            let ballX = px + dirX * offset;
            let ballY = py + dirY * offset;

            ballX = Math.max(BALL_RADIUS, Math.min(pRect.width - BALL_RADIUS, ballX));
            ballY = Math.max(BALL_RADIUS, Math.min(pRect.height - BALL_RADIUS, ballY));

            ballEl.style.left = (ballX - BALL_RADIUS) + "px";
            ballEl.style.top = (ballY - BALL_RADIUS) + "px";

            const bState = ballsState[0];
            if (bState) {
              bState.xRel = ballX / pRect.width;
              bState.yRel = ballY / pRect.height;
            }

            addBallTrailPoint(ballX, ballY);
          }
        }

      } else if (dragInfo.type === "goal" || dragInfo.type === "cone" || dragInfo.type === "ball") {
        dragInfo.el.classList.remove("dragging");
        dragInfo.el.releasePointerCapture(e.pointerId);
      } else if (dragInfo.type === "resize") {
        resizeHandle.releasePointerCapture(e.pointerId);
      }

      dragInfo = null;
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);

      renderState();
    }

    function resolveOverlapsForPlayer(id, pitchRect) {
      const playerEl = [...pitch.querySelectorAll(".player")].find(el => el.dataset.id === id);
      if (!playerEl) return;

      let x = parseFloat(playerEl.style.left) + PLAYER_RADIUS;
      let y = parseFloat(playerEl.style.top) + PLAYER_RADIUS;

      for (let step = 0; step < MAX_RELAX_STEPS; step++) {
        let moved = false;

        const others = playersState.filter(p => p.id !== id);
        for (const other of others) {
          const ox = other.xRel * pitchRect.width;
          const oy = other.yRel * pitchRect.height;

          const dx = x - ox;
          const dy = y - oy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < MIN_DIST && dist > 0) {
            const overlap = MIN_DIST - dist;
            const nx = dx / dist;
            const ny = dy / dist;

            x += nx * overlap * 0.6;
            y += ny * overlap * 0.6;

            moved = true;
          }
        }

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        if (!moved) break;
      }

      playerEl.style.left = (x - PLAYER_RADIUS) + "px";
      playerEl.style.top = (y - PLAYER_RADIUS) + "px";

      const pState = playersState.find(p => p.id === id);
      if (pState) {
        pState.xRel = x / pitchRect.width;
        pState.yRel = y / pitchRect.height;
      }
    }

    function renderGoals() {
      [...pitch.querySelectorAll(".goal")].forEach(el => el.remove());

      const pitchRect = pitch.getBoundingClientRect();

      for (const g of goalsState) {
        const el = document.createElement("div");
        el.className = "goal";
        el.dataset.id = g.id;

        const label = document.createElement("span");
        label.className = "goal-label";
        label.textContent = "Mål";
        el.appendChild(label);

        const x = g.xRel * pitchRect.width;
        const y = g.yRel * pitchRect.height;

        el.style.left = x + "px";
        el.style.top = y + "px";
        el.style.transform = `translate(-50%, -50%) rotate(${g.rotationDeg}deg)`;

        pitch.appendChild(el);
        setupGoalDrag(el);
      }
    }

    function renderCones() {
      [...pitch.querySelectorAll(".cone")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const c of conesState) {
        const el = document.createElement("div");
        el.className = "cone";
        el.dataset.id = c.id;

        const x = c.xRel * pitchRect.width;
        const y = c.yRel * pitchRect.height;

        const halfW = el.offsetWidth / 2 || 11;
        const halfH = el.offsetHeight / 2 || 11;

        el.style.left = (x - halfW) + "px";
        el.style.top = (y - halfH) + "px";

        pitch.appendChild(el);
        setupConeDrag(el);
      }
    }

    function renderBalls() {
      [...pitch.querySelectorAll(".ball")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const b of ballsState) {
        const el = document.createElement("div");
        el.className = "ball";
        el.dataset.id = b.id;

        const x = b.xRel * pitchRect.width;
        const y = b.yRel * pitchRect.height;

        const halfW = el.offsetWidth / 2 || 11;
        const halfH = el.offsetHeight / 2 || 11;

        el.style.left = (x - halfW) + "px";
        el.style.top = (y - halfH) + "px";

        pitch.appendChild(el);
        setupBallDrag(el);
      }
    }

    function renderAllSequencesPaths() {
      [...overlaySvg.querySelectorAll(".run-path")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const seq of drillSequences) {
        if (!seq.points || !seq.points.length) continue;
        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("id", seq.svgId);
        polyline.setAttribute("class", "run-path");
        const pts = seq.points
          .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
          .join(" ");
        polyline.setAttribute("points", pts);
        overlaySvg.appendChild(polyline);
      }
    }

    function addGoal() {
      // inte längre använd – allt skapas via drag
    }

    function clearGoals() {
      // kan läggas till vid behov
    }

    function clearCones() {
      // kan läggas till vid behov
    }

    function renderState() {
      const fullState = {
        players: playersState,
        goals: goalsState,
        cones: conesState,
        balls: ballsState,
        drillSequences,
        ballOwnerId,
        ballTrailPoints
      };
      stateOutput.textContent = JSON.stringify(fullState, null, 2);
    }

    resizeHandle.addEventListener("pointerdown", (e) => {
      const rect = pitch.getBoundingClientRect();
      resizeHandle.setPointerCapture(e.pointerId);
      dragInfo = {
        type: "resize",
        startY: e.clientY,
        startHeight: rect.height
      };
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    });

    undoBtn.addEventListener("click", () => {
      if (!undoStack.length) return;
      const snapshot = undoStack.pop();
      restoreStateFromSnapshot(snapshot);
    });

    showLinesCheckbox.addEventListener("change", () => {
      applyLinesClass();
    });

    setupConeDrag(coneSource);
    setupBallDrag(ballSource);
    setupPlayerSourceDrag(playerBlueSource, "blue");
    setupPlayerSourceDrag(playerRedSource, "red");
    setupGoalSourceDrag(goalSource);

    pitch.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    window.addEventListener("load", () => {
      setTimeout(() => {
        initPitchHeight();
        applyLinesClass();
        renderState();
      }, 100);
    });

    window.addEventListener("resize", () => {
      const rect = pitch.getBoundingClientRect();
      const currentRatio = rect.width / rect.height;
      const newHeight = rect.width / currentRatio;
      pitch.style.height = newHeight + "px";
      updateRatioDisplay();
      renderGoals();
      renderCones();
      renderBalls();
      renderAllSequencesPaths();
      renderBallTrail();
    });
  </script>
</body>
</html>
