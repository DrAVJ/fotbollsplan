<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fotbolls√∂vningar med inspelning - V4</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 16px;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 16px;
      color: #fff;
    }

    .settings-bar {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      padding: 12px;
      background: #2a2a2a;
      border-radius: 6px;
    }

    .top-bar {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      background: #2d5f3f;
      color: #fff;
    }

    button:hover {
      background: #3a7a52;
    }

    button.active {
      background: #ff9500;
    }

    button.secondary {
      background: #444;
    }

    button.secondary:hover {
      background: #555;
    }

    button.danger {
      background: #c0392b;
    }

    button.danger:hover {
      background: #e74c3c;
    }

    label {
      font-size: 0.9rem;
      color: #bbb;
    }

    input[type="number"] {
      width: 60px;
      padding: 6px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2a2a2a;
      color: #fff;
      font-size: 0.9rem;
    }

    .main-layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }

    .pitch-container {
      flex: 1;
      min-width: 0;
      display: flex;
      justify-content: center;
    }

    #pitchWrapper {
      position: relative;
      display: inline-block;
    }

    #pitch {
      position: relative;
      width: 70vw;
      height: 70vh;
      background: linear-gradient(180deg, #2d5f3f 0%, #1f4d2f 100%);
      border: 3px solid #fff;
      border-radius: 8px;
      overflow: visible;
      touch-action: none;
      clip-path: inset(0 -100px -100px -100px);
    }

    .pitch-line {
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    .midline {
      left: 0;
      right: 0;
      top: 50%;
      height: 2px;
      transform: translateY(-50%);
    }

    .center-circle {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 120px;
      height: 120px;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .center-spot {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .penalty-box {
      position: absolute;
      border: 2px solid rgba(255, 255, 255, 0.8);
    }

    .penalty-box-left {
      left: 50%;
      top: 0;
      width: 40%;
      height: 15%;
      transform: translateX(-50%);
    }

    .penalty-box-right {
      left: 50%;
      bottom: 0;
      width: 40%;
      height: 15%;
      transform: translateX(-50%);
    }

    .goal-area {
      position: absolute;
      border: 2px solid rgba(255, 255, 255, 0.8);
    }

    .goal-area-left {
      left: 50%;
      top: 0;
      width: 22%;
      height: 8%;
      transform: translateX(-50%);
    }

    .goal-area-right {
      left: 50%;
      bottom: 0;
      width: 22%;
      height: 8%;
      transform: translateX(-50%);
    }

    .goal {
      position: absolute;
      left: 50%;
      width: 80px;
      height: 30px;
      transform: translateX(-50%);
      box-sizing: border-box;
      border: 3px solid #fff;
      border-radius: 3px;
      background:
        linear-gradient(90deg, rgba(255,255,255,0.25) 1px, transparent 1px),
        linear-gradient(180deg, rgba(255,255,255,0.25) 1px, transparent 1px);
      background-size: 8px 8px;
      background-position: 0 0;
    }

    .goal-left {
      top: -30px;
      border-bottom: none;
    }

    .goal-right {
      bottom: -30px;
      border-top: none;
    }

    .cone {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-bottom: 20px solid #ffd700;
      cursor: grab;
      user-select: none;
      z-index: 10;
      transform-origin: center center;
      touch-action: none;
    }

    .cone:active {
      cursor: grabbing;
      transform: scale(1.1);
    }

    .player {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.9rem;
      cursor: grab;
      user-select: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: transform 0.1s;
      z-index: 20;
    }

    .player:active {
      cursor: grabbing;
      transform: scale(1.1);
    }

    .player.left {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
      color: #fff;
    }

    .player.right {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      color: #fff;
    }

    .ball {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff, #f0f0f0, #d0d0d0);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5), inset -2px -2px 4px rgba(0, 0, 0, 0.2);
      cursor: grab;
      user-select: none;
      border: 1px solid rgba(0, 0, 0, 0.2);
      z-index: 50;
    }

    .ball:active {
      cursor: grabbing;
    }

    .ball.held {
      pointer-events: none;
      z-index: 25;
    }

    .trace {
      position: absolute;
      pointer-events: none;
      stroke-dasharray: 5, 5;
      animation: dash 0.5s linear infinite;
      z-index: 5;
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -10;
      }
    }

    .sidebar {
      width: 80px;
      flex-shrink: 0;
      display: block;
    }

    .rec-panel {
      position: fixed;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 16px;
      max-width: 350px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
      display: none;
    }

    .rec-panel.active {
      display: block;
    }

    .rec-panel h3 {
      font-size: 1rem;
      margin-bottom: 12px;
      color: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .rec-panel .close-btn {
      background: #c0392b;
      border: none;
      color: #fff;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rec-panel .close-btn:hover {
      background: #e74c3c;
    }

    .rec-list {
      max-height: calc(80vh - 80px);
      overflow-y: auto;
    }

    .toggle-rec-btn {
      background: #2d5f3f;
      padding: 12px 16px;
      font-size: 1rem;
      width: 100%;
    }

    .toggle-rec-btn:hover {
      background: #3a7a52;
    }

    .line-controls {
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .line-controls h3 {
      font-size: 0.9rem;
      margin-bottom: 8px;
      color: #fff;
    }

    .line-control-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 0.85rem;
    }

    .line-control-row input[type="checkbox"] {
      cursor: pointer;
    }

    .line-control-row label {
      flex: 1;
      cursor: pointer;
      color: #ccc;
    }

    .line-control-row input[type="range"] {
      width: 80px;
    }

    .rec-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      padding: 6px;
      background: #333;
      border-radius: 4px;
    }

    .rec-row span {
      flex: 1;
      font-size: 0.85rem;
      color: #bbb;
    }

    .rec-row input {
      width: 50px;
      padding: 4px;
      font-size: 0.85rem;
    }

    .rec-row button {
      padding: 4px 8px;
      font-size: 0.75rem;
    }

    .resize-handle {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      cursor: nwse-resize;
      background: rgba(255, 255, 255, 0.2);
      border-top-left-radius: 4px;
    }

    .right-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .toolbar {
      display: flex;
      flex-direction: row;
      gap: 12px;
      padding: 12px;
      background: transparent;
      border-radius: 6px;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }

    .toolbar-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      padding: 4px;
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: grab;
      transition: all 0.2s;
      min-width: auto;
      min-height: auto;
      touch-action: none;
      user-select: none;
    }

    .toolbar-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.2);
    }

    .toolbar-item:active {
      cursor: grabbing;
      opacity: 0.7;
    }

    .toolbar-icon {
      font-size: 1.8rem;
      pointer-events: none;
      user-select: none;
    }

    .dragging-icon {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
      font-size: 1.8rem;
      opacity: 0.8;
    }

    .toolbar-label {
      display: none;
    }

    @media (max-width: 900px) {
      .main-layout {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
      }

      .top-bar {
        flex-direction: column;
      }

      .top-bar button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚öΩ Fotbolls√∂vningar med inspelning - V4</h1>

    <div class="settings-bar">
      <button onclick="toggleGoals()">Visa/d√∂lj m√•l</button>
      <button onclick="resetPositions()">√Öterst√§ll positioner</button>
    </div>

    <div class="toolbar">
      <div class="toolbar-item" data-type="player-left">
        <div class="toolbar-icon" onmousedown="startIconDrag(event, 'player-left', this)" ontouchstart="startIconDrag(event, 'player-left', this)">üîµ</div>
      </div>
      <div class="toolbar-item" data-type="player-right">
        <div class="toolbar-icon" onmousedown="startIconDrag(event, 'player-right', this)" ontouchstart="startIconDrag(event, 'player-right', this)">üî¥</div>
      </div>
      <div class="toolbar-item" data-type="cone">
        <div class="toolbar-icon" onmousedown="startIconDrag(event, 'cone', this)" ontouchstart="startIconDrag(event, 'cone', this)">üî∫</div>
      </div>
      <div class="toolbar-item" data-type="ball">
        <div class="toolbar-icon" onmousedown="startIconDrag(event, 'ball', this)" ontouchstart="startIconDrag(event, 'ball', this)">‚öΩ</div>
      </div>
      <div class="toolbar-item" data-type="goal-left">
        <div class="toolbar-icon" onmousedown="startIconDrag(event, 'goal-left', this)" ontouchstart="startIconDrag(event, 'goal-left', this)">ü•Ö</div>
      </div>
      <div class="toolbar-item" data-type="goal-right">
        <div class="toolbar-icon" onmousedown="startIconDrag(event, 'goal-right', this)" ontouchstart="startIconDrag(event, 'goal-right', this)">ü•Ö</div>
      </div>
    </div>

    <div class="main-layout">

      <div class="pitch-container">
        <div id="pitchWrapper">
          <div id="pitch">
            <div class="pitch-line midline" id="midline"></div>
            <div class="center-circle" id="centerCircle"></div>
            <div class="center-spot" id="centerSpot"></div>
            <div class="penalty-box penalty-box-left" id="penaltyLeft"></div>
            <div class="penalty-box penalty-box-right" id="penaltyRight"></div>
            <div class="goal-area goal-area-left" id="goalAreaLeft"></div>
            <div class="goal-area goal-area-right" id="goalAreaRight"></div>
            <div class="goal goal-left" id="goalLeft"></div>
            <div class="goal goal-right" id="goalRight"></div>
          </div>
          <div class="resize-handle" id="resizeHandle"></div>
        </div>
      </div>

      <div class="sidebar">
        <div class="right-controls">
          <div class="top-bar">
            <button id="recordBtn" onclick="toggleRecord()">üî¥ Spela in</button>
            <button onclick="playRecordings()">‚ñ∂Ô∏è Spela upp</button>
            <button onclick="stopPlayback()">‚èπÔ∏è Stoppa</button>
            <button class="secondary" onclick="restoreFromREC1()">üîÅ B√∂rja om</button>
            <button class="danger" onclick="clearRecordings()">üóëÔ∏è Rensa inspelningar</button>
          </div>

          <button class="toggle-rec-btn" onclick="toggleRecPanel()">üìã Inspelningar</button>

          <div class="line-controls">
            <h3>Planens linjer</h3>
            <div class="line-control-row">
              <input type="checkbox" id="showMidline" checked onchange="toggleLine('midline')">
              <label for="showMidline">Mittlinje</label>
            </div>
            <div class="line-control-row">
              <input type="checkbox" id="showCenterCircle" checked onchange="toggleLine('centerCircle')">
              <label for="showCenterCircle">Mittenring</label>
            </div>
            <div class="line-control-row">
              <label>Ringstorlek:</label>
              <input type="range" id="circleSize" min="60" max="200" value="120" oninput="updateCircleSize(this.value)">
            </div>
            <div class="line-control-row">
              <input type="checkbox" id="showCenterSpot" checked onchange="toggleLine('centerSpot')">
              <label for="showCenterSpot">Mittenpunkt</label>
            </div>
            <div class="line-control-row">
              <input type="checkbox" id="showPenaltyBoxes" checked onchange="togglePenaltyBoxes()">
              <label for="showPenaltyBoxes">Straffomr√•den</label>
            </div>
            <div class="line-control-row">
              <input type="checkbox" id="showGoalAreas" checked onchange="toggleGoalAreas()">
              <label for="showGoalAreas">M√•lomr√•den</label>
            </div>
          </div>
        </div>
      </div>

      <div class="rec-panel" id="recPanel">
        <h3>
          Inspelningar
          <button class="close-btn" onclick="toggleRecPanel()">√ó</button>
        </h3>
        <div id="recList" class="rec-list"></div>
      </div>
    </div>
  </div>

  <script>
    const pitch = document.getElementById('pitch');
    const pitchWrapper = document.getElementById('pitchWrapper');
    const resizeHandle = document.getElementById('resizeHandle');
    const recList = document.getElementById('recList');
    const recordBtn = document.getElementById('recordBtn');

    let leftCount = 3;
    let rightCount = 0;
    let ballCount = 1;
    let showGoals = true;

    let players = [];
    let balls = [];
    let cones = [];
    let traces = [];

    let playerCounter = 0;
    let coneCounter = 0;

    let dragInfo = null;
    let spacePressed = false;
    let ballTraceActive = null;

    let ballOwners = new Map();

    let recordings = [];
    let currentRecording = null;
    let recordMode = false;

    let isPlaying = false;
    let playbackRequestId = null;
    let playbackStartWall = 0;
    let playbackSteps = [];
    let playbackTotalDur = 0;

    let resizing = false;
    let resizeStartWidth = 0;
    let resizeStartHeight = 0;
    let resizeStartX = 0;
    let resizeStartY = 0;

    let goals = [];
    let goalCounter = 0;

    function init() {
      updatePlayers();
      setupIconDragDrop();
      setupResize();

      document.addEventListener('keydown', e => {
        if (e.code === 'Space' && !spacePressed) {
          e.preventDefault();
          spacePressed = true;
        }
      });

      document.addEventListener('keyup', e => {
        if (e.code === 'Space') {
          spacePressed = false;
          if (ballTraceActive) {
            ballTraceActive = null;
          }
        }
      });
    }

    function setupResize() {
      resizeHandle.addEventListener('pointerdown', e => {
        e.preventDefault();
        resizing = true;
        const rect = pitch.getBoundingClientRect();
        resizeStartWidth = rect.width;
        resizeStartHeight = rect.height;
        resizeStartX = e.clientX;
        resizeStartY = e.clientY;
        resizeHandle.setPointerCapture(e.pointerId);
        
        window.addEventListener('pointermove', onResizeMove);
        window.addEventListener('pointerup', onResizeUp);
      });
    }

    function onResizeMove(e) {
      if (!resizing) return;
      
      const dx = e.clientX - resizeStartX;
      const dy = e.clientY - resizeStartY;
      
      const newWidth = Math.max(300, resizeStartWidth + dx);
      const newHeight = Math.max(400, resizeStartHeight + dy);
      
      pitch.style.width = newWidth + 'px';
      pitch.style.height = newHeight + 'px';
    }

    function onResizeUp(e) {
      if (!resizing) return;
      resizing = false;
      resizeHandle.releasePointerCapture(e.pointerId);
      window.removeEventListener('pointermove', onResizeMove);
      window.removeEventListener('pointerup', onResizeUp);
    }

    function updatePlayers() {
      players.forEach(p => p.el.remove());
      balls.forEach(b => b.el.remove());
      traces.forEach(t => t.remove());

      players = [];
      balls = [];
      traces = [];
      ballOwners.clear();
    }

    let draggingIcon = null;
    let dragStartX = 0;
    let dragStartY = 0;
    let currentDragType = null;

    function startToolbarDrag(e, type) {
      e.dataTransfer.effectAllowed = 'copy';
      e.dataTransfer.setData('type', type);
    }

    function startIconDrag(e, type, iconElement) {
      e.preventDefault();
      e.stopPropagation();

      const rect = iconElement.getBoundingClientRect();
      dragStartX = e.clientX || (e.touches && e.touches[0].clientX);
      dragStartY = e.clientY || (e.touches && e.touches[0].clientY);
      currentDragType = type;

      draggingIcon = document.createElement('div');
      draggingIcon.className = 'dragging-icon';
      draggingIcon.textContent = iconElement.textContent;
      draggingIcon.style.left = rect.left + 'px';
      draggingIcon.style.top = rect.top + 'px';
      document.body.appendChild(draggingIcon);

      iconElement.style.opacity = '0.3';

      document.addEventListener('mousemove', onIconDragMove);
      document.addEventListener('mouseup', onIconDragEnd);
      document.addEventListener('touchmove', onIconDragMove);
      document.addEventListener('touchend', onIconDragEnd);
    }

    function onIconDragMove(e) {
      if (!draggingIcon) return;
      e.preventDefault();

      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);

      const dx = clientX - dragStartX;
      const dy = clientY - dragStartY;

      draggingIcon.style.left = (dragStartX + dx) + 'px';
      draggingIcon.style.top = (dragStartY + dy) + 'px';
    }

    function onIconDragEnd(e) {
      if (!draggingIcon) return;
      e.preventDefault();

      const clientX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
      const clientY = e.clientY || (e.changedTouches && e.changedTouches[0].clientY);

      const pitchRect = pitch.getBoundingClientRect();

      if (clientX >= pitchRect.left && clientX <= pitchRect.right &&
          clientY >= pitchRect.top && clientY <= pitchRect.bottom) {
        
        const x = clientX - pitchRect.left;
        const y = clientY - pitchRect.top;

        if (currentDragType === 'player-left') {
          createPlayer(`L${++playerCounter}`, 'left', x, y, playerCounter);
        } else if (currentDragType === 'player-right') {
          createPlayer(`R${++playerCounter}`, 'right', x, y, playerCounter);
        } else if (currentDragType === 'cone') {
          createCone(`C${++coneCounter}`, x, y);
        } else if (currentDragType === 'ball') {
          createBall(`B${balls.length + 1}`, x, y);
        } else if (currentDragType === 'goal-left') {
          createGoal(`GL${++goalCounter}`, 'left', x, y);
        } else if (currentDragType === 'goal-right') {
          createGoal(`GR${++goalCounter}`, 'right', x, y);
        }
      }

      document.body.removeChild(draggingIcon);
      draggingIcon = null;
      currentDragType = null;

      const toolbarIcons = document.querySelectorAll('.toolbar-icon');
      toolbarIcons.forEach(icon => icon.style.opacity = '1');

      document.removeEventListener('mousemove', onIconDragMove);
      document.removeEventListener('mouseup', onIconDragEnd);
      document.removeEventListener('touchmove', onIconDragMove);
      document.removeEventListener('touchend', onIconDragEnd);
    }

    function setupIconDragDrop() {
      pitch.addEventListener('dragover', e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
      });

      pitch.addEventListener('drop', e => {
        e.preventDefault();
        const type = e.dataTransfer.getData('type');
        const pitchRect = pitch.getBoundingClientRect();
        const x = e.clientX - pitchRect.left;
        const y = e.clientY - pitchRect.top;

        if (type === 'player-left') {
          createPlayer(`L${++playerCounter}`, 'left', x, y, playerCounter);
        } else if (type === 'player-right') {
          createPlayer(`R${++playerCounter}`, 'right', x, y, playerCounter);
        } else if (type === 'cone') {
          createCone(`C${++coneCounter}`, x, y);
        } else if (type === 'ball') {
          createBall(`B${balls.length + 1}`, x, y);
        } else if (type === 'goal-left') {
          createGoal(`GL${++goalCounter}`, 'left', x, y);
        } else if (type === 'goal-right') {
          createGoal(`GR${++goalCounter}`, 'right', x, y);
        }
      });

      pitch.addEventListener('touchmove', e => {
        e.preventDefault();
      }, { passive: false });

      const toolbarIcons = document.querySelectorAll('.toolbar-icon');
      toolbarIcons.forEach(icon => {
        let touchStartX, touchStartY;
        
        icon.addEventListener('touchstart', e => {
          const touch = e.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          icon.style.opacity = '0.5';
        });

        icon.addEventListener('touchmove', e => {
          e.preventDefault();
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - touchStartX);
          const dy = Math.abs(touch.clientY - touchStartY);
          
          if (dx > 10 || dy > 10) {
            icon.style.opacity = '0.3';
          }
        }, { passive: false });

        icon.addEventListener('touchend', e => {
          e.preventDefault();
          icon.style.opacity = '1';
          
          const touch = e.changedTouches[0];
          const pitchRect = pitch.getBoundingClientRect();
          
          if (touch.clientX >= pitchRect.left && touch.clientX <= pitchRect.right &&
              touch.clientY >= pitchRect.top && touch.clientY <= pitchRect.bottom) {
            
            const x = touch.clientX - pitchRect.left;
            const y = touch.clientY - pitchRect.top;
            const type = icon.parentElement.dataset.type;

            if (type === 'player-left') {
              createPlayer(`L${++playerCounter}`, 'left', x, y, playerCounter);
            } else if (type === 'player-right') {
              createPlayer(`R${++playerCounter}`, 'right', x, y, playerCounter);
            } else if (type === 'cone') {
              createCone(`C${++coneCounter}`, x, y);
            } else if (type === 'ball') {
              createBall(`B${balls.length + 1}`, x, y);
            } else if (type === 'goal-left') {
              createGoal(`GL${++goalCounter}`, 'left', x, y);
            } else if (type === 'goal-right') {
              createGoal(`GR${++goalCounter}`, 'right', x, y);
            }
          }
        });
      });
    }

    function createPlayer(id, side, x, y, num) {
      const el = document.createElement('div');
      el.className = `player ${side}`;
      el.id = id;
      el.textContent = num;
      el.style.left = (x - 18) + 'px';
      el.style.top = (y - 18) + 'px';
      pitch.appendChild(el);

      const player = { id, side, x, y, num, el, clickCount: 0, clickTimer: null };
      players.push(player);

      el.addEventListener('pointerdown', e => onPointerDown(e, player, 'player'));
      el.addEventListener('click', e => handleObjectClick(e, player, 'player'));
    }

    function createBall(id, x, y) {
      const el = document.createElement('div');
      el.className = 'ball';
      el.id = id;
      el.style.left = (x - 10) + 'px';
      el.style.top = (y - 10) + 'px';
      pitch.appendChild(el);

      const ball = { id, x, y, el, clickCount: 0, clickTimer: null };
      balls.push(ball);

      el.addEventListener('pointerdown', e => onPointerDown(e, ball, 'ball'));
      el.addEventListener('click', e => handleObjectClick(e, ball, 'ball'));
    }

    function createCone(id, x, y) {
      const el = document.createElement('div');
      el.className = 'cone';
      el.id = id;
      el.style.left = (x - 12) + 'px';
      el.style.top = (y - 10) + 'px';
      pitch.appendChild(el);

      const cone = { id, x, y, el, clickCount: 0, clickTimer: null };
      cones.push(cone);

      el.addEventListener('pointerdown', e => onPointerDown(e, cone, 'cone'));
      el.addEventListener('click', e => handleObjectClick(e, cone, 'cone'));
    }

    function createGoal(id, side, x, y) {
      const el = document.createElement('div');
      el.className = 'goal';
      el.id = id;
      el.style.position = 'absolute';
      el.style.width = '60px';
      el.style.height = '40px';
      el.style.border = '3px solid rgba(255, 255, 255, 0.9)';
      el.style.background = 'rgba(255, 255, 255, 0.15)';
      el.style.cursor = 'grab';
      el.style.zIndex = '100';
      el.style.left = (x - 30) + 'px';
      el.style.top = (y - 20) + 'px';
      pitch.appendChild(el);

      const goal = { id, side, x, y, el, rotation: 0, clickCount: 0, clickTimer: null };
      goals.push(goal);

      el.addEventListener('pointerdown', e => onPointerDown(e, goal, 'goal'));
      el.addEventListener('click', e => handleObjectClick(e, goal, 'goal'));
    }

    function checkBallOverlap(player) {
      const px = player.x;
      const py = player.y;
      const playerRadius = 18;

      for (const ball of balls) {
        const ownerData = ballOwners.get(ball.id);
        
        if (ownerData && ownerData.playerId === player.id) continue;

        const dx = ball.x - px;
        const dy = ball.y - py;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < playerRadius + 10) {
          const newOwnerData = { playerId: player.id, lastX: px, lastY: py };
          ballOwners.set(ball.id, newOwnerData);
          ball.el.classList.add('held');
          
          if (recordMode && currentRecording && currentRecording.actorId === player.id) {
            const hadNoBallBefore = currentRecording.heldBalls.length === 0;
            
            if (hadNoBallBefore) {
              recordings.push(currentRecording);
              
              const pitchRect = pitch.getBoundingClientRect();
              const now = performance.now();
              
              currentRecording = {
                id: `REC${recordings.length + 1}`,
                actorId: player.id,
                step: recordings.length + 1,
                startTime: now,
                frames: [],
                heldBalls: [ball.id],
                startPos: { xRel: player.x / pitchRect.width, yRel: player.y / pitchRect.height }
              };
              
              currentRecording.frames.push({
                t: 0,
                xRel: currentRecording.startPos.xRel,
                yRel: currentRecording.startPos.yRel
              });
            } else {
              const ballIndex = currentRecording.heldBalls.indexOf(ball.id);
              if (ballIndex === -1) {
                currentRecording.heldBalls.push(ball.id);
              }
            }
          }
        }
      }
    }

    function releaseBall(playerId) {
      for (const [ballId, ownerData] of ballOwners.entries()) {
        if (ownerData.playerId === playerId) {
          ballOwners.delete(ballId);
          const ball = balls.find(b => b.id === ballId);
          if (ball) {
            ball.el.classList.remove('held');
          }
        }
      }
    }

    function onPointerDown(e, obj, type) {
      e.preventDefault();
      e.stopPropagation();

      const el = obj.el;
      const rect = el.getBoundingClientRect();
      const pitchRect = pitch.getBoundingClientRect();

      el.setPointerCapture(e.pointerId);

      const radius = type === 'ball' ? 10 : type === 'cone' ? 12 : type === 'goal' ? 30 : 18;

      dragInfo = {
        obj,
        type,
        el,
        offsetX: e.clientX - rect.left - radius,
        offsetY: e.clientY - rect.top - radius,
        pitchRect
      };

      if (recordMode) {
        const pitchRect = pitch.getBoundingClientRect();
        currentRecording = {
          id: `REC${recordings.length + 1}`,
          actorId: obj.id,
          step: recordings.length + 1,
          startTime: performance.now(),
          frames: [],
          heldBalls: [],
          startPos: { xRel: obj.x / pitchRect.width, yRel: obj.y / pitchRect.height }
        };
        
        currentRecording.frames.push({ 
          t: 0, 
          xRel: currentRecording.startPos.xRel, 
          yRel: currentRecording.startPos.yRel 
        });
      }

      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
    }

    function onPointerMove(e) {
      if (!dragInfo) return;

      const { obj, type, el, offsetX, offsetY, pitchRect } = dragInfo;
      const radius = type === 'ball' ? 10 : type === 'cone' ? 8 : type === 'goal' ? 30 : 18;

      let x = e.clientX - pitchRect.left - offsetX;
      let y = e.clientY - pitchRect.top - offsetY;

      if (type !== 'ball') {
        x = Math.max(radius, Math.min(pitchRect.width - radius, x));
        y = Math.max(radius, Math.min(pitchRect.height - radius, y));
      } else {
        x = Math.max(radius - 100, Math.min(pitchRect.width - radius + 100, x));
        y = Math.max(radius - 100, Math.min(pitchRect.height - radius + 100, y));
      }

      el.style.left = (x - radius) + 'px';
      el.style.top = (y - radius) + 'px';

      obj.x = x;
      obj.y = y;

      if (type === 'ball') {
        checkBallInGoal(obj);
      }

      if (type === 'player') {
        checkBallOverlap(obj);
        
        for (const ball of balls) {
          const ownerData = ballOwners.get(ball.id);
          if (ownerData && ownerData.playerId === obj.id) {
            const dx = x - ownerData.lastX;
            const dy = y - ownerData.lastY;
            const angle = Math.atan2(dy, dx);
            const offsetDist = 25;
            
            ball.x = x + Math.cos(angle) * offsetDist;
            ball.y = y + Math.sin(angle) * offsetDist;
            ball.el.style.left = (ball.x - 10) + 'px';
            ball.el.style.top = (ball.y - 10) + 'px';
            
            ownerData.lastX = x;
            ownerData.lastY = y;
          }
        }
      }

      if (currentRecording && currentRecording.actorId === obj.id) {
        const t = (performance.now() - currentRecording.startTime) / 1000;
        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        currentRecording.frames.push({ t, xRel, yRel });
      }

      if (type === 'ball' && spacePressed) {
        if (!ballTraceActive || ballTraceActive.ball !== obj) {
          ballTraceActive = { ball: obj, points: [] };
        }
        ballTraceActive.points.push({ x, y });
        drawTrace(ballTraceActive);
      }
    }

    function onPointerUp(e) {
      if (!dragInfo) return;

      const { el, obj, type } = dragInfo;
      el.releasePointerCapture(e.pointerId);

      if (type === 'player') {
        releaseBall(obj.id);
      }

      if (currentRecording && currentRecording.actorId === dragInfo.obj.id) {
        recordings.push(currentRecording);
        currentRecording = null;
        renderRecList();
      }

      dragInfo = null;
      window.removeEventListener('pointermove', onPointerMove);
      window.removeEventListener('pointerup', onPointerUp);
    }

    function drawTrace(traceData) {
      const points = traceData.points;
      if (points.length < 2) return;

      let existing = traces.find(t => t.dataset.ball === traceData.ball.id);
      if (!existing) {
        existing = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        existing.classList.add('trace');
        existing.dataset.ball = traceData.ball.id;
        existing.style.position = 'absolute';
        existing.style.top = '0';
        existing.style.left = '0';
        existing.style.width = '100%';
        existing.style.height = '100%';
        existing.style.pointerEvents = 'none';
        pitch.appendChild(existing);
        traces.push(existing);
      }

      existing.innerHTML = '';
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      let d = `M ${points[0].x} ${points[0].y}`;
      for (let i = 1; i < points.length; i++) {
        d += ` L ${points[i].x} ${points[i].y}`;
      }
      path.setAttribute('d', d);
      path.setAttribute('stroke', '#ffeb3b');
      path.setAttribute('stroke-width', '3');
      path.setAttribute('fill', 'none');
      existing.appendChild(path);
    }

    function toggleGoals() {
      showGoals = !showGoals;
      const goals = pitch.querySelectorAll('.goal');
      goals.forEach(g => g.style.display = showGoals ? 'block' : 'none');
    }

    function resetPositions() {
      updatePlayers();
      cones.forEach(c => c.el.remove());
      cones = [];
      coneCounter = 0;
      traces.forEach(t => t.remove());
      traces = [];
      ballTraceActive = null;
      ballOwners.clear();
    }

    function toggleLine(id) {
      const el = document.getElementById(id);
      const checkbox = document.getElementById(`show${id.charAt(0).toUpperCase() + id.slice(1)}`);
      if (el) el.style.display = checkbox.checked ? 'block' : 'none';
    }

    function togglePenaltyBoxes() {
      const show = document.getElementById('showPenaltyBoxes').checked;
      document.getElementById('penaltyLeft').style.display = show ? 'block' : 'none';
      document.getElementById('penaltyRight').style.display = show ? 'block' : 'none';
    }

    function toggleGoalAreas() {
      const show = document.getElementById('showGoalAreas').checked;
      document.getElementById('goalAreaLeft').style.display = show ? 'block' : 'none';
      document.getElementById('goalAreaRight').style.display = show ? 'block' : 'none';
    }

    function updateCircleSize(size) {
      const circle = document.getElementById('centerCircle');
      if (circle) {
        circle.style.width = size + 'px';
        circle.style.height = size + 'px';
      }
    }

    function restoreFromREC1() {
      const rec1 = recordings.find(r => r.id === 'REC1');
      if (!rec1 || !rec1.snapshot) return;

      const pitchRect = pitch.getBoundingClientRect();

      rec1.snapshot.forEach(snap => {
        const obj = [...players, ...balls, ...cones, ...goals].find(o => o.id === snap.id);
        if (!obj) return;

        const x = snap.xRel * pitchRect.width;
        const y = snap.yRel * pitchRect.height;
        const el = obj.el;
        const radius = el.classList.contains('ball') ? 10 : el.classList.contains('cone') ? 8 : el.classList.contains('goal') ? 30 : 18;

        obj.x = x;
        obj.y = y;
        el.style.left = (x - radius) + 'px';
        el.style.top = (y - radius) + 'px';
      });

      ballOwners.clear();
      balls.forEach(b => b.el.classList.remove('held'));
    }

    function toggleRecord() {
      recordMode = !recordMode;
      recordBtn.classList.toggle('active', recordMode);
      recordBtn.textContent = recordMode ? 'üî¥ Spelar in...' : 'üî¥ Spela in';

      if (recordMode) {
        const pitchRect = pitch.getBoundingClientRect();

        if (!recordings.find(r => r.id === 'REC1')) {
          const rec1 = {
            id: 'REC1',
            actorId: 'ALL',
            step: 1,
            frames: [],
            snapshot: []
          };

          [...players, ...balls, ...cones, ...goals].forEach(obj => {
            rec1.snapshot.push({
              id: obj.id,
              xRel: obj.x / pitchRect.width,
              yRel: obj.y / pitchRect.height
            });
          });

          recordings.unshift(rec1);
          renderRecList();
        }
      } else if (!recordMode && currentRecording) {
        recordings.push(currentRecording);
        currentRecording = null;
        renderRecList();
      }
    }

    function renderRecList() {
      recList.innerHTML = '';

      if (recordings.length === 0) {
        recList.innerHTML = '<p style="color: #777; font-size: 0.85rem;">Inga inspelningar √§n</p>';
        return;
      }

      recordings.forEach((rec, index) => {
        const row = document.createElement('div');
        row.className = 'rec-row';

        const label = document.createElement('span');
        label.textContent = `${rec.id} (${rec.actorId})`;

        const input = document.createElement('input');
        input.type = 'number';
        input.min = '1';
        input.value = rec.step;
        input.addEventListener('change', () => {
          const v = parseInt(input.value, 10);
          rec.step = isNaN(v) || v < 1 ? 1 : v;
          input.value = rec.step;
        });

        const delBtn = document.createElement('button');
        delBtn.textContent = '√ó';
        delBtn.className = 'danger';
        delBtn.addEventListener('click', () => {
          recordings.splice(index, 1);
          renderRecList();
        });

        row.appendChild(label);
        row.appendChild(input);
        row.appendChild(delBtn);
        recList.appendChild(row);
      });
    }

    function playRecordings() {
      if (!recordings.length) return;

      const byStep = new Map();
      for (const rec of recordings) {
        if (!byStep.has(rec.step)) byStep.set(rec.step, []);
        byStep.get(rec.step).push(rec);
      }

      playbackSteps = [];
      const sortedSteps = Array.from(byStep.keys()).sort((a, b) => a - b);
      for (const step of sortedSteps) {
        const recs = byStep.get(step);
        let maxDur = 0;
        for (const rec of recs) {
          if (!rec.frames.length) continue;
          const t0 = rec.frames[0].t;
          const tEnd = rec.frames[rec.frames.length - 1].t;
          maxDur = Math.max(maxDur, tEnd - t0);
        }
        playbackSteps.push({ step, recs, duration: maxDur });
      }

      if (!playbackSteps.length) return;

      playbackTotalDur = playbackSteps.reduce((sum, s) => sum + s.duration, 0);
      isPlaying = true;
      playbackStartWall = performance.now();
      playbackLoop();
    }

    function playbackLoop() {
      if (!isPlaying) return;
      if (!playbackSteps.length) return;

      const now = performance.now();
      const tGlobal = (now - playbackStartWall) / 1000;
      const pitchRect = pitch.getBoundingClientRect();

      const tWrapped = playbackTotalDur > 0 ? (tGlobal % playbackTotalDur) : 0;

      let acc = 0;
      let current = playbackSteps[0];
      for (const s of playbackSteps) {
        if (tWrapped >= acc && tWrapped < acc + s.duration) {
          current = s;
          break;
        }
        acc += s.duration;
      }

      const localT = tWrapped - acc;

      for (const rec of current.recs) {
        const frames = rec.frames;
        if (!frames || frames.length < 2) continue;

        const t0 = frames[0].t;
        const tEnd = frames[frames.length - 1].t;
        const stepDur = tEnd - t0 || 0.001;
        const t = t0 + Math.min(localT, stepDur);

        let i = 0;
        while (i < frames.length - 1 && frames[i + 1].t < t) i++;
        const fA = frames[i];
        const fB = frames[Math.min(i + 1, frames.length - 1)];
        const span = (fB.t - fA.t) || 1e-6;
        const u = Math.max(0, Math.min(1, (t - fA.t) / span));

        const xRel = fA.xRel + (fB.xRel - fA.xRel) * u;
        const yRel = fA.yRel + (fB.yRel - fA.yRel) * u;

        const x = xRel * pitchRect.width;
        const y = yRel * pitchRect.height;

        const obj = [...players, ...balls, ...cones, ...goals].find(o => o.id === rec.actorId);
        if (obj) {
          const radius = obj.el.classList.contains('ball') ? 10 : obj.el.classList.contains('cone') ? 8 : obj.el.classList.contains('goal') ? 30 : 18;
          obj.el.style.left = (x - radius) + 'px';
          obj.el.style.top = (y - radius) + 'px';
          obj.x = x;
          obj.y = y;

          if (rec.heldBalls && rec.heldBalls.length > 0) {
            let prevX = i > 0 ? frames[i-1].xRel * pitchRect.width : x;
            let prevY = i > 0 ? frames[i-1].yRel * pitchRect.height : y;
            const dx = x - prevX;
            const dy = y - prevY;
            const angle = Math.atan2(dy, dx);
            const offsetDist = 25;

            for (const ballId of rec.heldBalls) {
              const ball = balls.find(b => b.id === ballId);
              if (ball) {
                ball.x = x + Math.cos(angle) * offsetDist;
                ball.y = y + Math.sin(angle) * offsetDist;
                ball.el.style.left = (ball.x - 10) + 'px';
                ball.el.style.top = (ball.y - 10) + 'px';
              }
            }
          }
        }
      }

      playbackRequestId = requestAnimationFrame(playbackLoop);
    }

    function stopPlayback() {
      isPlaying = false;
      if (playbackRequestId) cancelAnimationFrame(playbackRequestId);
    }

    function toggleRecPanel() {
      const panel = document.getElementById('recPanel');
      panel.classList.toggle('active');
    }

    function clearRecordings() {
      if (confirm('Vill du verkligen rensa alla inspelningar?')) {
        recordings = [];
        currentRecording = null;
        recordMode = false;
        recordBtn.classList.remove('active');
        recordBtn.textContent = 'üî¥ Spela in';
        renderRecList();
      }
    }

    function handleObjectClick(e, obj, type) {
      e.stopPropagation();
      
      obj.clickCount++;
      
      if (obj.clickTimer) {
        clearTimeout(obj.clickTimer);
      }
      
      obj.clickTimer = setTimeout(() => {
        if (obj.clickCount === 2 && type === 'goal') {
          obj.rotation = (obj.rotation + 45) % 360;
          obj.el.style.transform = `rotate(${obj.rotation}deg)`;
        } else if (obj.clickCount >= 3) {
          removeObject(obj, type);
        }
        obj.clickCount = 0;
      }, 300);
    }

    function removeObject(obj, type) {
      obj.el.remove();
      
      if (type === 'player') {
        const index = players.indexOf(obj);
        if (index > -1) players.splice(index, 1);
        releaseBall(obj.id);
      } else if (type === 'ball') {
        const index = balls.indexOf(obj);
        if (index > -1) balls.splice(index, 1);
        ballOwners.delete(obj.id);
      } else if (type === 'cone') {
        const index = cones.indexOf(obj);
        if (index > -1) cones.splice(index, 1);
      } else if (type === 'goal') {
        const index = goals.indexOf(obj);
        if (index > -1) goals.splice(index, 1);
      }
    }

    function checkBallInGoal(ball) {
      for (const goal of goals) {
        const dx = ball.x - goal.x;
        const dy = ball.y - goal.y;
        
        const cos = Math.cos(-goal.rotation * Math.PI / 180);
        const sin = Math.sin(-goal.rotation * Math.PI / 180);
        const localX = dx * cos - dy * sin;
        const localY = dx * sin + dy * cos;
        
        const goalWidth = 60;
        const goalHeight = 40;
        
        if (Math.abs(localX) < goalWidth / 2 && Math.abs(localY) < goalHeight / 2) {
          ball.el.style.opacity = '0.5';
          setTimeout(() => {
            if (ball.el) ball.el.style.opacity = '1';
          }, 500);
          return;
        }
      }
    }

    init();
  </script>
</body>
</html>
