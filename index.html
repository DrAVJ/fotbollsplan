<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Träningsplan – mål, spelare, konor & bollar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 16px;
      background: #111;
      color: #f5f5f5;
      box-sizing: border-box;
      min-height: 150vh;

      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    h1 {
      font-size: 1.2rem;
      margin-bottom: 8px;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .controls-row2 {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    .controls-row3 {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    input[type="number"] {
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #222;
      color: #f5f5f5;
      font-size: 0.9rem;
      width: 70px;
    }

    input[type="checkbox"] {
      width: 14px;
      height: 14px;
    }

    button {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      background: #2e8b57;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }

    button:active {
      transform: scale(0.97);
    }

    .wrapper {
      max-width: 600px;
      margin: 0 auto;
    }

    .pitch-wrapper {
      position: relative;
      -webkit-user-select: none;
      user-select: none;
    }

    .pitch {
      position: relative;
      width: 100%;
      background: #1f7a3c;
      border-radius: 12px;
      border: 2px solid #fff;
      overflow: hidden;
      touch-action: none;
      pointer-events: none;
    }

    .pitch.show-lines::before,
    .pitch.show-lines::after {
      content: "";
      position: absolute;
      pointer-events: none;
    }

    .pitch.show-lines::before {
      left: 0;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      height: 0;
      border-top: 2px solid #fff;
      opacity: 0.7;
    }

    .pitch.show-lines::after {
      width: 30%;
      height: 0;
      padding-top: 30%;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.5);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .pitch-resize-handle {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -14px;
      width: 80px;
      height: 14px;
      border-radius: 8px;
      background: #333;
      border: 1px solid #777;
      color: #ccc;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 15;
      cursor: ns-resize;
      touch-action: none;
      pointer-events: auto;
    }

    .player {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 0 0 2px #fff;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .player.blue {
      background: #007bff;
    }

    .player.red {
      background: #e53935;
    }

    .player.dragging {
      opacity: 0.8;
      cursor: grabbing;
    }

    .player.recording {
      box-shadow: 0 0 0 2px #ffd54f, 0 0 8px #ffeb3b;
    }

    .goal {
      position: absolute;
      width: 40px;
      height: 16px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.2);
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 10px;
      font-weight: 600;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
      transform-origin: center center;
    }

    .goal-label {
      pointer-events: none;
    }

    .goal-rotate {
      position: absolute;
      right: -10px;
      top: -10px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      pointer-events: auto;
    }

    .goal.dragging {
      opacity: 0.8;
    }

    .cone-icon {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: #ff9800;
      box-shadow: 0 0 0 2px #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: #111;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
      margin-left: 8px;
    }

    .cone {
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ff9800;
      box-shadow: 0 0 0 2px #fff;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .ball-icon {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: #ffffff;
      box-shadow: 0 0 0 2px #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: #000;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .ball {
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ffffff;
      box-shadow: 0 0 0 2px #000;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    /* vald ikon – guldig aura */
    .selected {
      box-shadow: 0 0 0 2px #ffd54f, 0 0 8px #ffeb3b;
    }

    /* SVG overlay för banor */
    .overlay-svg {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }

    .run-path {
      fill: none;
      stroke: #ffeb3b;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .ball-trail {
      fill: none;
      stroke: #ffffff;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    pre {
      margin-top: 16px;
      font-size: 0.75rem;
      background: #000;
      padding: 8px;
      border-radius: 6px;
      max-height: 180px;
      overflow: auto;

      -webkit-user-select: text;
      user-select: text;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Två lag – plan, mål, spelare, konor & bollar</h1>

    <div class="controls">
      <label for="blueCount">Blå:</label>
      <input id="blueCount" type="number" min="0" max="22" value="5" />
      <label for="redCount">Röda:</label>
      <input id="redCount" type="number" min="0" max="22" value="5" />
      <button id="generatePlayers">Slumpa lag</button>
      <button id="logState">Visa data</button>
    </div>

    <div class="controls-row2">
      <label>
        <input type="checkbox" id="showLines" checked />
        Visa mittlinje & cirkel
      </label>
      <span id="ratioDisplay">Ratio: 3:2</span>
    </div>

    <div class="controls-row3">
      <span>Mål:</span>
      <button id="addGoalBtn">Lägg till mål (max 4)</button>
      <button id="clearGoalsBtn">Ta bort alla mål</button>
      <span style="margin-left:12px;">Konor:</span>
      <div id="coneSource" class="cone-icon">K</div>
      <button id="clearConesBtn">Ta bort alla konor</button>
      <span style="margin-left:12px;">Bollar:</span>
      <div id="ballSource" class="ball-icon">B</div>
      <button id="undoBtn">Ångra</button>
    </div>

    <div class="pitch-wrapper">
      <div id="pitch" class="pitch show-lines"></div>
      <svg id="overlaySvg" class="overlay-svg"></svg>
      <div id="resizeHandle" class="pitch-resize-handle">Dra för längd</div>
    </div>

    <pre id="stateOutput"></pre>
  </div>

  <script>
    const pitch = document.getElementById("pitch");
    const resizeHandle = document.getElementById("resizeHandle");
    const blueCountInput = document.getElementById("blueCount");
    const redCountInput = document.getElementById("redCount");
    const generateBtn = document.getElementById("generatePlayers");
    const logStateBtn = document.getElementById("logState");
    const stateOutput = document.getElementById("stateOutput");
    const showLinesCheckbox = document.getElementById("showLines");
    const ratioDisplay = document.getElementById("ratioDisplay");
    const addGoalBtn = document.getElementById("addGoalBtn");
    const clearGoalsBtn = document.getElementById("clearGoalsBtn");
    const coneSource = document.getElementById("coneSource");
    const clearConesBtn = document.getElementById("clearConesBtn");
    const ballSource = document.getElementById("ballSource");
    const undoBtn = document.getElementById("undoBtn");
    const overlaySvg = document.getElementById("overlaySvg");

    let playersState = [];
    let goalsState = [];
    let conesState = [];
    let ballsState = [];
    let coneCounter = 0;
    let ballCounter = 0;
    let dragInfo = null;

    const PLAYER_RADIUS = 16;
    const BALL_RADIUS = 11;
    const MIN_DIST = PLAYER_RADIUS * 2 * 1.1;
    const MAX_RELAX_STEPS = 20;
    const MAX_GOALS = 4;

    // Undo
    let undoStack = [];
    const UNDO_LIMIT = 10;

    // Drill-sekvenser (spelare)
    let drillSequences = [];
    let recordingSequence = null;
    let recordingActorId = null;
    let recordingStartTime = 0;
    let longPressTimer = null;
    let longPressThreshold = 500;
    let pointerDownTime = 0;
    let pointerMovedTooMuch = false;
    let pointerDownPos = null;

    // Boll-ägande och trail
    let ballOwnerId = null;
    let ballTrailPoints = [];

    function pushUndoState() {
      const snapshot = JSON.parse(JSON.stringify({
        playersState,
        goalsState,
        conesState,
        ballsState,
        drillSequences,
        ballOwnerId,
        ballTrailPoints
      }));
      undoStack.push(snapshot);
      if (undoStack.length > UNDO_LIMIT) {
        undoStack.shift();
      }
    }

    function restoreStateFromSnapshot(snapshot) {
      playersState = JSON.parse(JSON.stringify(snapshot.playersState));
      goalsState = JSON.parse(JSON.stringify(snapshot.goalsState));
      conesState = JSON.parse(JSON.stringify(snapshot.conesState));
      ballsState = JSON.parse(JSON.stringify(snapshot.ballsState));
      drillSequences = JSON.parse(JSON.stringify(snapshot.drillSequences));
      ballOwnerId = snapshot.ballOwnerId || null;
      ballTrailPoints = snapshot.ballTrailPoints || [];

      [...pitch.querySelectorAll(".player")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".goal")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".cone")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".ball")].forEach(el => el.remove());
      while (overlaySvg.firstChild) overlaySvg.removeChild(overlaySvg.firstChild);

      const pitchRect = pitch.getBoundingClientRect();

      for (const p of playersState) {
        const el = document.createElement("div");
        el.className = "player " + p.team;
        el.dataset.id = p.id;
        el.dataset.team = p.team;
        el.textContent = p.id.startsWith("B") ? p.id.slice(1) : p.id.slice(1);
        const x = p.xRel * pitchRect.width;
        const y = p.yRel * pitchRect.height;
        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";
        pitch.appendChild(el);
        setupPlayerDrag(el);
      }

      renderGoals();
      renderCones();
      renderBalls();
      renderAllSequencesPaths();
      renderBallTrail();
      renderState();
    }

    function initPitchHeight() {
      const rect = pitch.getBoundingClientRect();
      const targetHeight = rect.width * (2 / 3);
      pitch.style.height = targetHeight + "px";
      updateRatioDisplay();
    }

    function updateRatioDisplay() {
      const rect = pitch.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      const ratio = (w / h).toFixed(2);
      ratioDisplay.textContent = "Ratio: " + ratio + " : 1";
    }

    function applyLinesClass() {
      if (showLinesCheckbox.checked) {
        pitch.classList.add("show-lines");
      } else {
        pitch.classList.remove("show-lines");
      }
    }

    function createPlayers() {
      [...pitch.querySelectorAll(".player")].forEach(el => el.remove());
      playersState = [];

      applyLinesClass();

      const blueCount = Math.max(0, Math.min(22, Number(blueCountInput.value) || 0));
      const redCount = Math.max(0, Math.min(22, Number(redCountInput.value) || 0));
      const pitchRect = pitch.getBoundingClientRect();

      const placed = [];

      for (const g of goalsState) {
        placed.push({ x: g.xRel * pitchRect.width, y: g.yRel * pitchRect.height });
      }
      for (const c of conesState) {
        placed.push({ x: c.xRel * pitchRect.width, y: c.yRel * pitchRect.height });
      }
      for (const b of ballsState) {
        placed.push({ x: b.xRel * pitchRect.width, y: b.yRel * pitchRect.height });
      }

      for (let i = 1; i <= blueCount; i++) {
        const { x, y, xRel, yRel } = getNonOverlappingPosition(placed, pitchRect, "top");
        placed.push({ x, y });

        const el = document.createElement("div");
        el.className = "player blue";
        el.textContent = i;
        el.dataset.id = `B${i}`;
        el.dataset.team = "blue";

        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";

        pitch.appendChild(el);
        setupPlayerDrag(el);

        playersState.push({ id: `B${i}`, team: "blue", xRel, yRel });
      }

      for (let j = 1; j <= redCount; j++) {
        const { x, y, xRel, yRel } = getNonOverlappingPosition(placed, pitchRect, "bottom");
        placed.push({ x, y });

        const el = document.createElement("div");
        el.className = "player red";
        el.textContent = j;
        el.dataset.id = `R${j}`;
        el.dataset.team = "red";

        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";

        pitch.appendChild(el);
        setupPlayerDrag(el);

        playersState.push({ id: `R${j}`, team: "red", xRel, yRel });
      }

      renderState();
    }

    function getNonOverlappingPosition(placed, pitchRect, side) {
      let xRel, yRel, x, y;
      let tries = 0;
      const maxTries = 300;

      do {
        const marginX = 0.05;
        const marginY = 0.05;

        const xMin = marginX;
        const xMax = 1 - marginX;
        xRel = xMin + Math.random() * (xMax - xMin);

        if (side === "top") {
          const yMin = marginY;
          const yMax = 0.5 - marginY;
          yRel = yMin + Math.random() * (yMax - yMin);
        } else if (side === "bottom") {
          const yMin = 0.5 + marginY;
          const yMax = 1 - marginY;
          yRel = yMin + Math.random() * (yMax - yMin);
        } else {
          const margin = 0.08;
          yRel = margin + Math.random() * (1 - 2 * margin);
        }

        x = xRel * pitchRect.width;
        y = yRel * pitchRect.height;

        tries++;
      } while (isTooClose(x, y, placed) && tries < maxTries);

      return { x, y, xRel, yRel };
    }

    function isTooClose(x, y, placed) {
      for (const p of placed) {
        const dx = x - p.x;
        const dy = y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < MIN_DIST) return true;
      }
      return false;
    }

    function clearSelectionHighlight() {
      [...pitch.querySelectorAll(".player, .ball, .cone, .goal")].forEach(el => {
        el.classList.remove("selected");
      });
    }

    function setupPlayerDrag(el) {
      el.addEventListener("pointerdown", onPointerDownPlayer);
    }

    function onPointerDownPlayer(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      const target = e.currentTarget;
      const id = target.dataset.id;

      target.setPointerCapture(e.pointerId);
      target.classList.add("dragging");

      const rect = target.getBoundingClientRect();
      const pitchRect = pitch.getBoundingClientRect();

      const centerX = rect.left - pitchRect.left + PLAYER_RADIUS;
      const centerY = rect.top - pitchRect.top + PLAYER_RADIUS;

      dragInfo = {
        type: "player",
        id,
        el: target,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect,
        pointerId: e.pointerId,
        prevX: centerX,
        prevY: centerY,
        lastDirX: 0,
        lastDirY: -1 // default "framåt" uppåt
      };

      pointerDownTime = performance.now();
      pointerMovedTooMuch = false;
      pointerDownPos = { x: e.clientX, y: e.clientY };
      longPressTimer = setTimeout(() => {
        startRecordingForActor(id, target, pitchRect, e);
      }, longPressThreshold);

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function cancelLongPressTimer() {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }

    function startRecordingForActor(actorId, el, pitchRect, e) {
      recordingActorId = actorId;
      recordingStartTime = performance.now();
      const seqId = "SEQ" + (drillSequences.length + 1);
      const kind = "run";
      recordingSequence = {
        id: seqId,
        actorId,
        kind,
        startAt: 0,
        points: [],
        svgId: seqId
      };
      drillSequences.push(recordingSequence);
      el.classList.add("recording");

      const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      polyline.setAttribute("id", seqId);
      polyline.setAttribute("class", "run-path");
      polyline.setAttribute("points", "");
      overlaySvg.appendChild(polyline);

      const x = e.clientX - pitchRect.left;
      const y = e.clientY - pitchRect.top;
      addRecordingPoint(x, y);
    }

    function addRecordingPoint(x, y) {
      if (!recordingSequence) return;
      const pitchRect = pitch.getBoundingClientRect();
      const t = (performance.now() - recordingStartTime) / 1000;
      const xRel = x / pitchRect.width;
      const yRel = y / pitchRect.height;
      recordingSequence.points.push({ t, xRel, yRel });

      const polyline = document.getElementById(recordingSequence.svgId);
      if (polyline) {
        const pts = recordingSequence.points
          .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
          .join(" ");
        polyline.setAttribute("points", pts);
      }
    }

    function stopRecording() {
      if (!recordingSequence) return;
      const actorEl = [...pitch.querySelectorAll(".player")].find(el => el.dataset.id === recordingActorId);
      if (actorEl) actorEl.classList.remove("recording");
      if (recordingSequence.points.length > 0) {
        const firstT = recordingSequence.points[0].t;
        const lastT = recordingSequence.points[recordingSequence.points.length - 1].t;
        recordingSequence.duration = lastT - firstT;
      } else {
        recordingSequence.duration = 0;
      }
      recordingSequence = null;
      recordingActorId = null;
    }

    function setupGoalDrag(el) {
      el.addEventListener("pointerdown", (e) => {
        clearSelectionHighlight();
        el.classList.add("selected");

        if (e.target.classList.contains("goal-rotate")) return;

        const target = el;
        const id = target.dataset.id;

        target.setPointerCapture(e.pointerId);
        target.classList.add("dragging");

        const rect = target.getBoundingClientRect();
        const pitchRect = pitch.getBoundingClientRect();

        dragInfo = {
          type: "goal",
          id,
          el: target,
          offsetX: e.clientX - rect.left,
          offsetY: e.clientY - rect.top,
          pitchRect
        };

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", onPointerUp);
      });

      const rotateBtn = el.querySelector(".goal-rotate");
      rotateBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        pushUndoState();
        const id = el.dataset.id;
        const gState = goalsState.find(g => g.id === id);
        if (!gState) return;
        gState.rotationDeg = (gState.rotationDeg + 90) % 360;
        el.style.transform = `translate(-50%, -50%) rotate(${gState.rotationDeg}deg)`;
        renderState();
      });
    }

    function setupConeDrag(el) {
      el.addEventListener("pointerdown", onPointerDownCone);
    }

    function setupBallDrag(el) {
      el.addEventListener("pointerdown", onPointerDownBall);
    }

    function onPointerDownCone(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      const pitchRect = pitch.getBoundingClientRect();
      const source = e.currentTarget;

      if (source.id === "coneSource") {
        pushUndoState();
        coneCounter++;
        const id = "C" + coneCounter;
        const coneEl = document.createElement("div");
        coneEl.className = "cone";
        coneEl.dataset.id = id;

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(coneEl);
        const halfW = coneEl.offsetWidth / 2;
        const halfH = coneEl.offsetHeight / 2;
        coneEl.style.left = (x - halfW) + "px";
        coneEl.style.top = (y - halfH) + "px";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        conesState.push({ id, xRel, yRel });

        setupConeDrag(coneEl);
        coneEl.addEventListener("dblclick", onConeDblClick);

        startConeDrag(e, coneEl, id, pitchRect);
      } else {
        const id = source.dataset.id;
        startConeDrag(e, source, id, pitchRect);
      }
    }

    function onPointerDownBall(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      // Ta över kontrollen: bollen blir fri
      ballOwnerId = null;

      const pitchRect = pitch.getBoundingClientRect();
      const source = e.currentTarget;

      if (source.id === "ballSource") {
        pushUndoState();
        ballCounter++;
        const id = "BAll" + ballCounter;
        const ballEl = document.createElement("div");
        ballEl.className = "ball";
        ballEl.dataset.id = id;

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(ballEl);
        const halfW = ballEl.offsetWidth / 2;
        const halfH = ballEl.offsetHeight / 2;
        ballEl.style.left = (x - halfW) + "px";
        ballEl.style.top = (y - halfH) + "px";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        ballsState.push({ id, xRel, yRel });

        setupBallDrag(ballEl);
        ballEl.addEventListener("dblclick", onBallDblClick);

        startBallDrag(e, ballEl, id, pitchRect);
      } else {
        const id = source.dataset.id;
        startBallDrag(e, source, id, pitchRect);
      }

      // Nollställ trail när man börjar dra bollen
      ballTrailPoints = [];
      renderBallTrail();
    }

    function startConeDrag(e, el, id, pitchRect) {
      e.stopPropagation();
      el.setPointerCapture(e.pointerId);
      el.classList.add("dragging");

      const rect = el.getBoundingClientRect();

      dragInfo = {
        type: "cone",
        id,
        el,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect
      };

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function startBallDrag(e, el, id, pitchRect) {
      e.stopPropagation();
      el.setPointerCapture(e.pointerId);
      el.classList.add("dragging");

      const rect = el.getBoundingClientRect();
      const centerX = rect.left - pitchRect.left + BALL_RADIUS;
      const centerY = rect.top - pitchRect.top + BALL_RADIUS;

      dragInfo = {
        type: "ball",
        id,
        el,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect,
        prevX: centerX,
        prevY: centerY
      };

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function onConeDblClick(e) {
      e.stopPropagation();
      const el = e.currentTarget;
      const id = el.dataset.id;
      const idx = conesState.findIndex(c => c.id === id);
      if (idx === -1) return;
      pushUndoState();
      conesState.splice(idx, 1);
      el.remove();
      renderState();
    }

    function onBallDblClick(e) {
      e.stopPropagation();
      const el = e.currentTarget;
      const id = el.dataset.id;
      const idx = ballsState.findIndex(b => b.id === id);
      if (idx === -1) return;
      pushUndoState();
      ballsState.splice(idx, 1);
      el.remove();
      renderState();
    }

    function addBallTrailPoint(x, y) {
      const pitchRect = pitch.getBoundingClientRect();
      const xRel = x / pitchRect.width;
      const yRel = y / pitchRect.height;
      const last = ballTrailPoints[ballTrailPoints.length - 1];
      const pitchX = x;
      const pitchY = y;
      if (last) {
        const lastX = last.xRel * pitchRect.width;
        const lastY = last.yRel * pitchRect.height;
        const dist = Math.hypot(pitchX - lastX, pitchY - lastY);
        if (dist < 3) return; // filtrera små rörelser
      }
      ballTrailPoints.push({ xRel, yRel });
      renderBallTrail();
    }

    function renderBallTrail() {
      const old = document.getElementById("ballTrail");
      if (old) overlaySvg.removeChild(old);

      if (!ballTrailPoints.length) return;
      const pitchRect = pitch.getBoundingClientRect();

      const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      poly.setAttribute("id", "ballTrail");
      poly.setAttribute("class", "ball-trail");
      const pts = ballTrailPoints
        .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
        .join(" ");
      poly.setAttribute("points", pts);
      overlaySvg.appendChild(poly);
    }

    function onPointerMove(e) {
      if (!dragInfo) return;

      const moveDist = pointerDownPos
        ? Math.hypot(e.clientX - pointerDownPos.x, e.clientY - pointerDownPos.y)
        : 0;
      if (moveDist > 10) {
        pointerMovedTooMuch = true;
      }

      if (dragInfo.type === "player") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + PLAYER_RADIUS;
        let y = e.clientY - pitchRect.top - offsetY + PLAYER_RADIUS;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        const prevX = dragInfo.prevX;
        const prevY = dragInfo.prevY;
        const dx = x - prevX;
        const dy = y - prevY;

        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";

        const pState = playersState.find(p => p.id === id);
        if (pState) {
          pState.xRel = x / pitchRect.width;
          pState.yRel = y / pitchRect.height;
        }

        // uppdatera riktning
        let dirX = dragInfo.lastDirX;
        let dirY = dragInfo.lastDirY;
        const len = Math.hypot(dx, dy);
        if (len > 0.5) {
          dirX = dx / len;
          dirY = dy / len;
          dragInfo.lastDirX = dirX;
          dragInfo.lastDirY = dirY;
        }

        // om spelaren har bollen, flytta bollen framför
        if (ballOwnerId === id) {
          const ballEl = pitch.querySelector(".ball");
          if (ballEl) {
            const offset = PLAYER_RADIUS + BALL_RADIUS;
            const ballX = x + dirX * offset;
            const ballY = y + dirY * offset;

            const clampedX = Math.max(BALL_RADIUS, Math.min(pitchRect.width - BALL_RADIUS, ballX));
            const clampedY = Math.max(BALL_RADIUS, Math.min(pitchRect.height - BALL_RADIUS, ballY));

            ballEl.style.left = (clampedX - BALL_RADIUS) + "px";
            ballEl.style.top = (clampedY - BALL_RADIUS) + "px";

            const bState = ballsState[0];
            if (bState) {
              bState.xRel = clampedX / pitchRect.width;
              bState.yRel = clampedY / pitchRect.height;
            }

            addBallTrailPoint(clampedX, clampedY);
          }
        }

        dragInfo.prevX = x;
        dragInfo.prevY = y;

        if (recordingActorId === id && recordingSequence) {
          addRecordingPoint(x, y);
        }

        if (pointerMovedTooMuch) {
          cancelLongPressTimer();
        }

      } else if (dragInfo.type === "goal") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + el.offsetWidth / 2;
        let y = e.clientY - pitchRect.top - offsetY + el.offsetHeight / 2;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        el.style.left = x + "px";
        el.style.top = y + "px";

        const gState = goalsState.find(g => g.id === id);
        if (gState) {
          gState.xRel = x / pitchRect.width;
          gState.yRel = y / pitchRect.height;
        }
      } else if (dragInfo.type === "cone") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + el.offsetWidth / 2;
        let y = e.clientY - pitchRect.top - offsetY + el.offsetHeight / 2;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        el.style.left = (x - el.offsetWidth / 2) + "px";
        el.style.top = (y - el.offsetHeight / 2) + "px";

        const cState = conesState.find(c => c.id === id);
        if (cState) {
          cState.xRel = x / pitchRect.width;
          cState.yRel = y / pitchRect.height;
        }
      } else if (dragInfo.type === "ball") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + BALL_RADIUS;
        let y = e.clientY - pitchRect.top - offsetY + BALL_RADIUS;

        x = Math.max(BALL_RADIUS, Math.min(pitchRect.width - BALL_RADIUS, x));
        y = Math.max(BALL_RADIUS, Math.min(pitchRect.height - BALL_RADIUS, y));

        el.style.left = (x - BALL_RADIUS) + "px";
        el.style.top = (y - BALL_RADIUS) + "px";

        const bState = ballsState.find(b => b.id === id);
        if (bState) {
          bState.xRel = x / pitchRect.width;
          bState.yRel = y / pitchRect.height;
        }

        addBallTrailPoint(x, y);

      } else if (dragInfo.type === "resize") {
        const { startY, startHeight } = dragInfo;
        const dy = e.clientY - startY;
        let newHeight = startHeight + dy;

        const rect = pitch.getBoundingClientRect();
        const minHeight = rect.width * 0.4;
        const maxHeight = rect.width * 1.6;

        newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
        pitch.style.height = newHeight + "px";

        updateRatioDisplay();
      }
    }

    function onPointerUp(e) {
      if (!dragInfo) return;

      if (dragInfo.type === "player") {
        const { pitchRect, id, el } = dragInfo;
        el.classList.remove("dragging");
        el.releasePointerCapture(e.pointerId);

        cancelLongPressTimer();
        stopRecording();

        resolveOverlapsForPlayer(id, pitchRect);

        // Kolla om spelaren nu har bollen (överlappar)
        const ballEl = pitch.querySelector(".ball");
        if (ballEl) {
          const ballRect = ballEl.getBoundingClientRect();
          const playerRect = el.getBoundingClientRect();
          const pitchRect = pitch.getBoundingClientRect();

          const px = playerRect.left - pitchRect.left + PLAYER_RADIUS;
          const py = playerRect.top - pitchRect.top + PLAYER_RADIUS;
          const bx = ballRect.left - pitchRect.left + BALL_RADIUS;
          const by = ballRect.top - pitchRect.top + BALL_RADIUS;

          const dist = Math.hypot(px - bx, py - by);
          if (dist < PLAYER_RADIUS + BALL_RADIUS + 2) {
            // Spelaren tar bollen
            ballOwnerId = id;

            // placera bollen kant-i-kant framför i senaste riktning
            const dirX = dragInfo.lastDirX || 0;
            const dirY = dragInfo.lastDirY || -1;
            const offset = PLAYER_RADIUS + BALL_RADIUS;
            let ballX = px + dirX * offset;
            let ballY = py + dirY * offset;

            ballX = Math.max(BALL_RADIUS, Math.min(pitchRect.width - BALL_RADIUS, ballX));
            ballY = Math.max(BALL_RADIUS, Math.min(pitchRect.height - BALL_RADIUS, ballY));

            ballEl.style.left = (ballX - BALL_RADIUS) + "px";
            ballEl.style.top = (ballY - BALL_RADIUS) + "px";

            const bState = ballsState[0];
            if (bState) {
              bState.xRel = ballX / pitchRect.width;
              bState.yRel = ballY / pitchRect.height;
            }

            addBallTrailPoint(ballX, ballY);
          }
        }

      } else if (dragInfo.type === "goal") {
        dragInfo.el.classList.remove("dragging");
        dragInfo.el.releasePointerCapture(e.pointerId);
      } else if (dragInfo.type === "cone") {
        dragInfo.el.classList.remove("dragging");
        dragInfo.el.releasePointerCapture(e.pointerId);
      } else if (dragInfo.type === "ball") {
        dragInfo.el.classList.remove("dragging");
        dragInfo.el.releasePointerCapture(e.pointerId);
      } else if (dragInfo.type === "resize") {
        resizeHandle.releasePointerCapture(e.pointerId);
      }

      dragInfo = null;
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);

      renderState();
    }

    function resolveOverlapsForPlayer(id, pitchRect) {
      const playerEl = [...pitch.querySelectorAll(".player")].find(el => el.dataset.id === id);
      if (!playerEl) return;

      let x = parseFloat(playerEl.style.left) + PLAYER_RADIUS;
      let y = parseFloat(playerEl.style.top) + PLAYER_RADIUS;

      for (let step = 0; step < MAX_RELAX_STEPS; step++) {
        let moved = false;

        const others = playersState.filter(p => p.id !== id);
        for (const other of others) {
          const ox = other.xRel * pitchRect.width;
          const oy = other.yRel * pitchRect.height;

          const dx = x - ox;
          const dy = y - oy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < MIN_DIST && dist > 0) {
            const overlap = MIN_DIST - dist;
            const nx = dx / dist;
            const ny = dy / dist;

            x += nx * overlap * 0.6;
            y += ny * overlap * 0.6;

            moved = true;
          }
        }

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        if (!moved) break;
      }

      playerEl.style.left = (x - PLAYER_RADIUS) + "px";
      playerEl.style.top = (y - PLAYER_RADIUS) + "px";

      const pState = playersState.find(p => p.id === id);
      if (pState) {
        pState.xRel = x / pitchRect.width;
        pState.yRel = y / pitchRect.height;
      }
    }

    function renderGoals() {
      [...pitch.querySelectorAll(".goal")].forEach(el => el.remove());

      const pitchRect = pitch.getBoundingClientRect();

      for (const g of goalsState) {
        const el = document.createElement("div");
        el.className = "goal";
        el.dataset.id = g.id;

        const label = document.createElement("span");
        label.className = "goal-label";
        label.textContent = "Mål";
        el.appendChild(label);

        const rotateBtn = document.createElement("div");
        rotateBtn.className = "goal-rotate";
        rotateBtn.textContent = "⟳";
        el.appendChild(rotateBtn);

        const x = g.xRel * pitchRect.width;
        const y = g.yRel * pitchRect.height;

        el.style.left = x + "px";
        el.style.top = y + "px";
        el.style.transform = `translate(-50%, -50%) rotate(${g.rotationDeg}deg)`;

        pitch.appendChild(el);
        setupGoalDrag(el);
      }
    }

    function renderCones() {
      [...pitch.querySelectorAll(".cone")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const c of conesState) {
        const el = document.createElement("div");
        el.className = "cone";
        el.dataset.id = c.id;

        const x = c.xRel * pitchRect.width;
        const y = c.yRel * pitchRect.height;

        const halfW = el.offsetWidth / 2 || 11;
        const halfH = el.offsetHeight / 2 || 11;

        el.style.left = (x - halfW) + "px";
        el.style.top = (y - halfH) + "px";

        pitch.appendChild(el);
        setupConeDrag(el);
        el.addEventListener("dblclick", onConeDblClick);
      }
    }

    function renderBalls() {
      [...pitch.querySelectorAll(".ball")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const b of ballsState) {
        const el = document.createElement("div");
        el.className = "ball";
        el.dataset.id = b.id;

        const x = b.xRel * pitchRect.width;
        const y = b.yRel * pitchRect.height;

        const halfW = el.offsetWidth / 2 || 11;
        const halfH = el.offsetHeight / 2 || 11;

        el.style.left = (x - halfW) + "px";
        el.style.top = (y - halfH) + "px";

        pitch.appendChild(el);
        setupBallDrag(el);
        el.addEventListener("dblclick", onBallDblClick);
      }
    }

    function renderAllSequencesPaths() {
      [...overlaySvg.querySelectorAll(".run-path")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const seq of drillSequences) {
        if (!seq.points || !seq.points.length) continue;
        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("id", seq.svgId);
        polyline.setAttribute("class", "run-path");
        const pts = seq.points
          .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
          .join(" ");
        polyline.setAttribute("points", pts);
        overlaySvg.appendChild(polyline);
      }
    }

    function addGoal() {
      if (goalsState.length >= MAX_GOALS) return;
      pushUndoState();

      const xRel = 0.5;
      const yRel = 0.95;
      const id = "G" + (goalsState.length + 1);

      goalsState.push({
        id,
        xRel,
        yRel,
        rotationDeg: 0
      });

      renderGoals();
      renderState();
    }

    function clearGoals() {
      if (!goalsState.length) return;
      pushUndoState();
      goalsState = [];
      renderGoals();
      renderState();
    }

    function clearCones() {
      if (!conesState.length) return;
      pushUndoState();
      conesState = [];
      renderCones();
      renderState();
    }

    function renderState() {
      const fullState = {
        players: playersState,
        goals: goalsState,
        cones: conesState,
        balls: ballsState,
        drillSequences,
        ballOwnerId,
        ballTrailPoints
      };
      stateOutput.textContent = JSON.stringify(fullState, null, 2);
    }

    resizeHandle.addEventListener("pointerdown", (e) => {
      const rect = pitch.getBoundingClientRect();
      resizeHandle.setPointerCapture(e.pointerId);
      dragInfo = {
        type: "resize",
        startY: e.clientY,
        startHeight: rect.height
      };
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    });

    generateBtn.addEventListener("click", () => {
      pushUndoState();
      createPlayers();
      renderGoals();
      renderCones();
      renderBalls();
      renderAllSequencesPaths();
      renderBallTrail();
    });

    logStateBtn.addEventListener("click", renderState);
    showLinesCheckbox.addEventListener("change", () => {
      applyLinesClass();
    });
    addGoalBtn.addEventListener("click", addGoal);
    clearGoalsBtn.addEventListener("click", clearGoals);
    clearConesBtn.addEventListener("click", clearCones);

    undoBtn.addEventListener("click", () => {
      if (!undoStack.length) return;
      const snapshot = undoStack.pop();
      restoreStateFromSnapshot(snapshot);
    });

    setupConeDrag(coneSource);
    setupBallDrag(ballSource);

    pitch.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    window.addEventListener("load", () => {
      setTimeout(() => {
        initPitchHeight();
        applyLinesClass();
        createPlayers();
        renderGoals();
        renderCones();
        renderBalls();
        renderAllSequencesPaths();
        renderBallTrail();
      }, 100);
    });

    window.addEventListener("resize", () => {
      const rect = pitch.getBoundingClientRect();
      const currentRatio = rect.width / rect.height;
      const newHeight = rect.width / currentRatio;
      pitch.style.height = newHeight + "px";
      updateRatioDisplay();
      renderGoals();
      renderCones();
      renderBalls();
      renderAllSequencesPaths();
      renderBallTrail();
    });
  </script>
</body>
</html>
