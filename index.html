<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Träningsplan – dra in alla objekt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden; /* ingen scroll */
    }

    body {
      font-family: system-ui, sans-serif;
      background: #111;
      color: #f5f5f5;
      box-sizing: border-box;
    }

    h1 {
      font-size: 1.2rem;
      margin: 0 0 8px 0;
    }

    .wrapper {
      max-width: 600px;
      margin: 0 auto;
      padding: 16px;
      height: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .controls-row2 {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.8rem;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.8rem;
      align-items: center;
    }

    .palette-label {
      margin-right: 4px;
    }

    .palette-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
    }

    input[type="checkbox"] {
      width: 14px;
      height: 14px;
    }

    button {
      padding: 4px 8px;
      border-radius: 4px;
      border: none;
      background: #2e8b57;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.8rem;
    }

    button:active {
      transform: scale(0.97);
    }

    .pitch-wrapper {
      position: relative;
      -webkit-user-select: none;
      user-select: none;
      flex: 1;
      display: flex;
      align-items: stretch;
    }

    .pitch {
      position: relative;
      width: 100%;
      background: #1f7a3c;
      border-radius: 12px;
      border: 2px solid #fff;
      overflow: hidden;
      touch-action: none;
      pointer-events: none;
    }

    .pitch-resize-handle {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -14px;
      width: 80px;
      height: 14px;
      border-radius: 8px;
      background: #333;
      border: 1px solid #777;
      color: #ccc;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 15;
      cursor: ns-resize;
      touch-action: none;
      pointer-events: auto;
    }

    #midline {
      position: absolute;
      left: 0;
      right: 0;
      height: 0;
      border-top: 2px solid #fff;
      opacity: 0.7;
      pointer-events: auto;
      cursor: ns-resize;
    }

    #centerCircle {
      position: absolute;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.5);
      pointer-events: none;
    }

    .player {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 0 0 2px #fff;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .player.blue {
      background: #007bff;
    }

    .player.red {
      background: #e53935;
    }

    .player.dragging {
      opacity: 0.8;
      cursor: grabbing;
    }

    .player.recording {
      box-shadow: 0 0 0 2px #ffd54f, 0 0 8px #ffeb3b;
    }

    .goal {
      position: absolute;
      width: 60px;
      height: 18px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.2);
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 10px;
      font-weight: 600;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
      transform-origin: center center;
    }

    .goal-label {
      pointer-events: none;
    }

    .cone-icon,
    .ball-icon,
    .player-blue-icon,
    .player-red-icon {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .goal-icon {
      border-radius: 6px;
      width: 40px;
      height: 18px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .cone-icon {
      background: #ff9800;
      box-shadow: 0 0 0 2px #fff;
      color: #111;
    }

    .ball-icon {
      background: #ffffff;
      box-shadow: 0 0 0 2px #000;
      color: #000;
    }

    .player-blue-icon {
      background: #007bff;
      box-shadow: 0 0 0 2px #fff;
      color: #fff;
    }

    .player-red-icon {
      background: #e53935;
      box-shadow: 0 0 0 2px #fff;
      color: #fff;
    }

    .cone {
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ff9800;
      box-shadow: 0 0 0 2px #fff;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .ball {
      position: absolute;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ffffff;
      box-shadow: 0 0 0 2px #000;
      user-select: none;
      touch-action: none;
      cursor: grab;
      pointer-events: auto;
    }

    .selected {
      box-shadow: 0 0 0 2px #ffd54f, 0 0 8px #ffeb3b;
    }

    .overlay-svg {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }

    .run-path {
      fill: none;
      stroke: #ffeb3b;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .ball-trail {
      fill: none;
      stroke: #ffffff;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Plan – dra in spelare, mål, konor & bollar</h1>

    <div class="controls-row2">
      <label>
        <input type="checkbox" id="showLines" checked />
        Visa mittlinje & cirkel
      </label>
      <span id="ratioDisplay">Ratio: 3:2</span>
      <button id="undoBtn">Ångra</button>
      <button id="moveMidlineBtn">Flytta mittlinje</button>
      <button id="circleMinus">- cirkel</button>
      <button id="circlePlus">+ cirkel</button>
      <button id="recordToggleBtn">Inspelning</button>
      <button id="playAllBtn">Spela upp</button>
      <button id="stopPlayBtn">Stoppa</button>
    </div>

    <div class="palette">
      <span class="palette-label">Dra in på planen:</span>

      <div class="palette-item">
        <div id="playerBlueSource" class="player-blue-icon">B</div>
        <span>Blå</span>
      </div>

      <div class="palette-item">
        <div id="playerRedSource" class="player-red-icon">R</div>
        <span>Röd</span>
      </div>

      <div class="palette-item">
        <div id="goalSource" class="goal-icon">Mål</div>
        <span>Mål</span>
      </div>

      <div class="palette-item">
        <div id="coneSource" class="cone-icon">K</div>
        <span>Kona</span>
      </div>

      <div class="palette-item">
        <div id="ballSource" class="ball-icon">B</div>
        <span>Boll</span>
      </div>
    </div>

    <div class="pitch-wrapper">
      <div id="pitch" class="pitch show-lines"></div>
      <div id="midline"></div>
      <div id="centerCircle"></div>
      <svg id="overlaySvg" class="overlay-svg"></svg>
      <div id="resizeHandle" class="pitch-resize-handle">Dra för längd</div>
    </div>
  </div>

  <script>
    const pitch = document.getElementById("pitch");
    const resizeHandle = document.getElementById("resizeHandle");
    const showLinesCheckbox = document.getElementById("showLines");
    const ratioDisplay = document.getElementById("ratioDisplay");
    const undoBtn = document.getElementById("undoBtn");
    const overlaySvg = document.getElementById("overlaySvg");
    const midlineEl = document.getElementById("midline");
    const centerCircleEl = document.getElementById("centerCircle");
    const moveMidlineBtn = document.getElementById("moveMidlineBtn");
    const circleMinusBtn = document.getElementById("circleMinus");
    const circlePlusBtn = document.getElementById("circlePlus");
    const playAllBtn = document.getElementById("playAllBtn");
    const stopPlayBtn = document.getElementById("stopPlayBtn");
    const recordToggleBtn = document.getElementById("recordToggleBtn");

    const playerBlueSource = document.getElementById("playerBlueSource");
    const playerRedSource = document.getElementById("playerRedSource");
    const goalSource = document.getElementById("goalSource");
    const coneSource = document.getElementById("coneSource");
    const ballSource = document.getElementById("ballSource");

    let playersState = [];
    let goalsState = [];
    let conesState = [];
    let ballsState = [];
    let dragInfo = null;

    let playerBlueCounter = 0;
    let playerRedCounter = 0;
    let goalCounter = 0;
    let coneCounter = 0;
    let ballCounter = 0;

    const PLAYER_RADIUS = 16;
    const BALL_RADIUS = 11;
    const MIN_DIST = PLAYER_RADIUS * 2 * 1.1;
    const MAX_RELAX_STEPS = 20;

    // Undo
    let undoStack = [];
    const UNDO_LIMIT = 10;

    // Spelar-drill (gammal per-spelare-sekvens – låter ligga tills vi byter playback)
    let drillSequences = [];
    let recordingSequence = null;
    let recordingActorId = null;
    let recordingStartTime = 0;

    // Boll-ägande och trail
    let ballOwnerId = null;
    let ballTrailPoints = [];

    // Mittlinje & cirkel
    let midlineYRel = 0.5;
    let midlineMoveMode = false;
    let centerCircleRadiusRel = 0.15;

    // Playback
    let isPlaying = false;
    let playbackStartTime = 0;
    let playbackRequestId = null;

    // Inspelningsläge (gammal)
    let recordMode = false;

    // --- Ny global inspelningsstruktur ---
    let recordings = [];          // alla inspelningar
    let currentRecording = null;  // inspelning som pågår nu
    let currentStep = 1;          // Steg 1, Steg 2, ...

    function fitPitchHeight() {
      const wrapperRect = document.querySelector(".wrapper").getBoundingClientRect();
      const controlsRect = document.querySelector(".controls-row2").getBoundingClientRect();
      const paletteRect = document.querySelector(".palette").getBoundingClientRect();
      const top = wrapperRect.top + controlsRect.height + paletteRect.height + 24;
      const available = window.innerHeight - top - 24;
      const minHeight = 200;
      const maxHeight = available;
      let current = pitch.getBoundingClientRect().height || available;
      current = Math.max(minHeight, Math.min(maxHeight, current));
      pitch.style.height = current + "px";
    }

    function pushUndoState() {
      const snapshot = JSON.parse(JSON.stringify({
        playersState,
        goalsState,
        conesState,
        ballsState,
        drillSequences,
        ballOwnerId,
        ballTrailPoints,
        midlineYRel,
        centerCircleRadiusRel
      }));
      undoStack.push(snapshot);
      if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    }

    function restoreStateFromSnapshot(snapshot) {
      playersState = JSON.parse(JSON.stringify(snapshot.playersState));
      goalsState = JSON.parse(JSON.stringify(snapshot.goalsState));
      conesState = JSON.parse(JSON.stringify(snapshot.conesState));
      ballsState = JSON.parse(JSON.stringify(snapshot.ballsState));
      drillSequences = JSON.parse(JSON.stringify(snapshot.drillSequences));
      ballOwnerId = snapshot.ballOwnerId || null;
      ballTrailPoints = snapshot.ballTrailPoints || [];
      midlineYRel = snapshot.midlineYRel ?? 0.5;
      centerCircleRadiusRel = snapshot.centerCircleRadiusRel ?? 0.15;

      [...pitch.querySelectorAll(".player")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".goal")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".cone")].forEach(el => el.remove());
      [...pitch.querySelectorAll(".ball")].forEach(el => el.remove());
      while (overlaySvg.firstChild) overlaySvg.removeChild(overlaySvg.firstChild);

      const pitchRect = pitch.getBoundingClientRect();

      for (const p of playersState) {
        const el = document.createElement("div");
        el.className = "player " + p.team;
        el.dataset.id = p.id;
        el.dataset.team = p.team;
        el.textContent = p.team === "blue" ? p.id.replace("B", "") : p.id.replace("R", "");
        const x = p.xRel * pitchRect.width;
        const y = p.yRel * pitchRect.height;
        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";
        pitch.appendChild(el);
        setupPlayerDrag(el);
        setupClickHandlers(el);
      }

      renderGoals();
      renderCones();
      renderBalls();
      renderAllSequencesPaths();
      renderBallTrail();
      renderMidline();
      renderCenterCircle();
    }

    function updateRatioDisplay() {
      const rect = pitch.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      const ratio = (w / h).toFixed(2);
      ratioDisplay.textContent = "Ratio: " + ratio + " : 1";
    }

    function applyLinesClass() {
      if (showLinesCheckbox.checked) {
        midlineEl.style.display = "";
        centerCircleEl.style.display = "";
      } else {
        midlineEl.style.display = "none";
        centerCircleEl.style.display = "none";
      }
    }

    function clearSelectionHighlight() {
      [...pitch.querySelectorAll(".player, .ball, .cone, .goal")].forEach(el => {
        el.classList.remove("selected");
      });
    }

    // Klick-logik: trippel = ta bort, dubbel på mål = rotera
    function setupClickHandlers(el) {
      let clickCount = 0;
      let clickTimer = null;

      el.addEventListener("click", (e) => {
        if (e.detail === 3) {
          handleTripleClick(el);
          return;
        }

        clickCount++;
        if (clickTimer) clearTimeout(clickTimer);

        clickTimer = setTimeout(() => {
          if (clickCount === 2 && el.classList.contains("goal")) {
            rotateGoal(el);
          }
          clickCount = 0;
          clickTimer = null;
        }, 250);
      });
    }

    function handleTripleClick(el) {
      const id = el.dataset.id;
      const type = getElementType(el);

      pushUndoState();

      if (type === "player") {
        clearSequenceForPlayer(id);
        const idx = playersState.findIndex(p => p.id === id);
        if (idx !== -1) playersState.splice(idx, 1);
      } else if (type === "goal") {
        const idx = goalsState.findIndex(g => g.id === id);
        if (idx !== -1) goalsState.splice(idx, 1);
      } else if (type === "cone") {
        const idx = conesState.findIndex(c => c.id === id);
        if (idx !== -1) conesState.splice(idx, 1);
      } else if (type === "ball") {
        const idx = ballsState.findIndex(b => b.id === id);
        if (idx !== -1) ballsState.splice(idx, 1);
      }

      el.remove();
    }

    function getElementType(el) {
      if (el.classList.contains("player")) return "player";
      if (el.classList.contains("goal")) return "goal";
      if (el.classList.contains("cone")) return "cone";
      if (el.classList.contains("ball")) return "ball";
      return null;
    }

    function rotateGoal(el) {
      const id = el.dataset.id;
      const gState = goalsState.find(g => g.id === id);
      if (!gState) return;
      pushUndoState();
      gState.rotationDeg = (gState.rotationDeg + 90) % 360;
      el.style.transform = `translate(-50%, -50%) rotate(${gState.rotationDeg}deg)`;
    }

    // Rensa trail för en spelare
    function clearSequenceForPlayer(playerId) {
      const keep = [];
      for (const seq of drillSequences) {
        if (seq.actorId !== playerId) {
          keep.push(seq);
        } else {
          const el = document.getElementById(seq.svgId);
          if (el) el.remove();
        }
      }
      drillSequences = keep;
    }

    // DRAG: spelare
    function setupPlayerDrag(el) {
      el.addEventListener("pointerdown", onPointerDownPlayer);
    }

    function onPointerDownPlayer(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      const target = e.currentTarget;
      const id = target.dataset.id;

      pushUndoState();
      clearSequenceForPlayer(id);

      target.setPointerCapture(e.pointerId);
      target.classList.add("dragging");

      const rect = target.getBoundingClientRect();
      const pitchRect = pitch.getBoundingClientRect();

      const centerX = rect.left - pitchRect.left + PLAYER_RADIUS;
      const centerY = rect.top - pitchRect.top + PLAYER_RADIUS;

      dragInfo = {
        type: "player",
        id,
        el: target,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect,
        pointerId: e.pointerId,
        prevX: centerX,
        prevY: centerY,
        lastDirX: 0,
        lastDirY: -1
      };

      if (recordMode) {
        recordingActorId = id;
        recordingStartTime = performance.now();
        const seqId = "SEQ" + (drillSequences.length + 1);
        recordingSequence = {
          id: seqId,
          actorId: id,
          kind: "run",
          startAt: 0,
          points: [],
          svgId: seqId
        };
        drillSequences.push(recordingSequence);
        target.classList.add("recording");

        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("id", seqId);
        polyline.setAttribute("class", "run-path");
        polyline.setAttribute("points", "");
        overlaySvg.appendChild(polyline);

        addRecordingPoint(centerX, centerY);
      } else {
        recordingSequence = null;
        recordingActorId = null;
      }

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function addRecordingPoint(x, y) {
      if (!recordingSequence) return;
      const pitchRect = pitch.getBoundingClientRect();
      const t = (performance.now() - recordingStartTime) / 1000;
      const xRel = x / pitchRect.width;
      const yRel = y / pitchRect.height;
      recordingSequence.points.push({ t, xRel, yRel });

      const polyline = document.getElementById(recordingSequence.svgId);
      if (polyline) {
        const pts = recordingSequence.points
          .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
          .join(" ");
        polyline.setAttribute("points", pts);
      }
    }

    function stopRecording() {
      if (!recordingSequence) return;
      const actorEl = [...pitch.querySelectorAll(".player")].find(el => el.dataset.id === recordingActorId);
      if (actorEl) actorEl.classList.remove("recording");
      if (recordingSequence.points.length > 0) {
        const firstT = recordingSequence.points[0].t;
        const lastT = recordingSequence.points[recordingSequence.points.length - 1].t;
        recordingSequence.duration = lastT - firstT;
      } else {
        recordingSequence.duration = 0;
      }
      recordingSequence = null;
      recordingActorId = null;
    }

    // DRAG: mål / konor / boll
    function setupGoalDrag(el) {
      el.addEventListener("pointerdown", (e) => {
        clearSelectionHighlight();
        el.classList.add("selected");

        pushUndoState();

        const target = el;
        const id = target.dataset.id;

        target.setPointerCapture(e.pointerId);
        target.classList.add("dragging");

        const rect = target.getBoundingClientRect();
        const pitchRect = pitch.getBoundingClientRect();

        dragInfo = {
          type: "goal",
          id,
          el: target,
          offsetX: e.clientX - rect.left,
          offsetY: e.clientY - rect.top,
          pitchRect
        };

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", onPointerUp);
      });
      setupClickHandlers(el);
    }

    function setupConeDrag(el) {
      el.addEventListener("pointerdown", onPointerDownCone);
      setupClickHandlers(el);
    }

    function setupBallDrag(el) {
      el.addEventListener("pointerdown", onPointerDownBall);
      setupClickHandlers(el);
    }

    function onPointerDownCone(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      const pitchRect = pitch.getBoundingClientRect();
      const source = e.currentTarget;

      pushUndoState();

      if (source === coneSource) {
        coneCounter++;
        const id = "C" + coneCounter;
        const coneEl = document.createElement("div");
        coneEl.className = "cone";
        coneEl.dataset.id = id;

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(coneEl);
        const halfW = coneEl.offsetWidth / 2;
        const halfH = coneEl.offsetHeight / 2;
        coneEl.style.left = (x - halfW) + "px";
        coneEl.style.top = (y - halfH) + "px";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        conesState.push({ id, xRel, yRel });

        setupConeDrag(coneEl);

        startConeDrag(e, coneEl, id, pitchRect);
      } else {
        const id = source.dataset.id;
        startConeDrag(e, source, id, pitchRect);
      }
    }

    function onPointerDownBall(e) {
      clearSelectionHighlight();
      e.currentTarget.classList.add("selected");

      ballOwnerId = null;

      const pitchRect = pitch.getBoundingClientRect();
      const source = e.currentTarget;

      pushUndoState();

      if (source === ballSource) {
        ballCounter++;
        const id = "BAll" + ballCounter;
        const ballEl = document.createElement("div");
        ballEl.className = "ball";
        ballEl.dataset.id = id;

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(ballEl);
        const halfW = ballEl.offsetWidth / 2;
        const halfH = ballEl.offsetHeight / 2;
        ballEl.style.left = (x - halfW) + "px";
        ballEl.style.top = (y - halfH) + "px";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        ballsState.push({ id, xRel, yRel });

        setupBallDrag(ballEl);

        startBallDrag(e, ballEl, id, pitchRect);
      } else {
        const id = source.dataset.id;
        startBallDrag(e, source, id, pitchRect);
      }

      ballTrailPoints = [];
      renderBallTrail();
    }

    function startConeDrag(e, el, id, pitchRect) {
      e.stopPropagation();
      el.setPointerCapture(e.pointerId);
      el.classList.add("dragging");

      const rect = el.getBoundingClientRect();

      dragInfo = {
        type: "cone",
        id,
        el,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect
      };

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function startBallDrag(e, el, id, pitchRect) {
      e.stopPropagation();
      el.setPointerCapture(e.pointerId);
      el.classList.add("dragging");

      const rect = el.getBoundingClientRect();
      const centerX = rect.left - pitchRect.left + BALL_RADIUS;
      const centerY = rect.top - pitchRect.top + BALL_RADIUS;

      dragInfo = {
        type: "ball",
        id,
        el,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        pitchRect,
        prevX: centerX,
        prevY: centerY
      };

      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    }

    function addBallTrailPoint(x, y) {
      const pitchRect = pitch.getBoundingClientRect();
      const xRel = x / pitchRect.width;
      const yRel = y / pitchRect.height;
      const last = ballTrailPoints[ballTrailPoints.length - 1];
      if (last) {
        const lastX = last.xRel * pitchRect.width;
        const lastY = last.yRel * pitchRect.height;
        const dist = Math.hypot(x - lastX, y - lastY);
        if (dist < 3) return;
      }
      ballTrailPoints.push({ xRel, yRel });
      renderBallTrail();
    }

    function renderBallTrail() {
      const old = document.getElementById("ballTrail");
      if (old) overlaySvg.removeChild(old);
      if (!ballTrailPoints.length) return;

      const pitchRect = pitch.getBoundingClientRect();
      const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
      poly.setAttribute("id", "ballTrail");
      poly.setAttribute("class", "ball-trail");
      const pts = ballTrailPoints
        .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
        .join(" ");
      poly.setAttribute("points", pts);
      overlaySvg.appendChild(poly);
    }

    // --- Ny funktion: sampleFrame (alla spelare + bollar) ---
    function sampleFrame() {
      if (!recordMode || !currentRecording) return;

      const t = (performance.now() - currentRecording.startTime) / 1000;
      const frame = {
        t,
        players: {},
        balls: {}
      };

      for (const p of playersState) {
        frame.players[p.id] = { xRel: p.xRel, yRel: p.yRel };
      }
      for (const b of ballsState) {
        frame.balls[b.id] = { xRel: b.xRel, yRel: b.yRel };
      }

      currentRecording.frames.push(frame);
    }

    // Drag: källor för spelare
    function setupPlayerSourceDrag(sourceEl, team) {
      sourceEl.addEventListener("pointerdown", (e) => {
        clearSelectionHighlight();
        const pitchRect = pitch.getBoundingClientRect();

        pushUndoState();

        const isBlue = team === "blue";
        if (isBlue) playerBlueCounter++;
        else playerRedCounter++;
        const id = isBlue ? "B" + playerBlueCounter : "R" + playerRedCounter;

        const playerEl = document.createElement("div");
        playerEl.className = "player " + team;
        playerEl.dataset.id = id;
        playerEl.dataset.team = team;
        playerEl.textContent = isBlue ? playerBlueCounter : playerRedCounter;

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(playerEl);
        const half = PLAYER_RADIUS;
        playerEl.style.left = (x - half) + "px";
        playerEl.style.top = (y - half) + "px";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        playersState.push({ id, team, xRel, yRel });

        setupPlayerDrag(playerEl);
        setupClickHandlers(playerEl);
        playerEl.classList.add("selected");

        playerEl.dispatchEvent(new PointerEvent("pointerdown", {
          clientX: e.clientX,
          clientY: e.clientY,
          pointerId: e.pointerId,
          bubbles: true
        }));
      });
    }

    // Drag: mål-källa
    function setupGoalSourceDrag(sourceEl) {
      sourceEl.addEventListener("pointerdown", (e) => {
        clearSelectionHighlight();
        const pitchRect = pitch.getBoundingClientRect();

        pushUndoState();
        goalCounter++;
        const id = "G" + goalCounter;

        const goalEl = document.createElement("div");
        goalEl.className = "goal";
        goalEl.dataset.id = id;

        const label = document.createElement("span");
        label.className = "goal-label";
        label.textContent = "Mål";
        goalEl.appendChild(label);

        let x = e.clientX - pitchRect.left;
        let y = e.clientY - pitchRect.top;
        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        pitch.appendChild(goalEl);
        goalEl.style.left = x + "px";
        goalEl.style.top = y + "px";
        goalEl.style.transform = "translate(-50%, -50%) rotate(0deg)";

        const xRel = x / pitchRect.width;
        const yRel = y / pitchRect.height;
        goalsState.push({ id, xRel, yRel, rotationDeg: 0 });

        setupGoalDrag(goalEl);
        goalEl.classList.add("selected");

        goalEl.dispatchEvent(new PointerEvent("pointerdown", {
          clientX: e.clientX,
          clientY: e.clientY,
          pointerId: e.pointerId,
          bubbles: true
        }));
      });
    }

    function onPointerMove(e) {
      if (!dragInfo) return;

      if (dragInfo.type === "player") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + PLAYER_RADIUS;
        let y = e.clientY - pitchRect.top - offsetY + PLAYER_RADIUS;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        const prevX = dragInfo.prevX;
        const prevY = dragInfo.prevY;
        const dx = x - prevX;
        const dy = y - prevY;

        el.style.left = (x - PLAYER_RADIUS) + "px";
        el.style.top = (y - PLAYER_RADIUS) + "px";

        const pState = playersState.find(p => p.id === id);
        if (pState) {
          pState.xRel = x / pitchRect.width;
          pState.yRel = y / pitchRect.height;
        }

        let dirX = dragInfo.lastDirX;
        let dirY = dragInfo.lastDirY;
        const len = Math.hypot(dx, dy);
        if (len > 0.1) {
          const newX = dx / len;
          const newY = dy / len;
          const alpha = 0.3;
          dirX = dirX * (1 - alpha) + newX * alpha;
          dirY = dirY * (1 - alpha) + newY * alpha;
          const dlen = Math.hypot(dirX, dirY);
          if (dlen > 0) {
            dirX /= dlen;
            dirY /= dlen;
          }
          dragInfo.lastDirX = dirX;
          dragInfo.lastDirY = dirY;
        }

        if (ballOwnerId === id) {
          const ballEl = pitch.querySelector(".ball");
          if (ballEl) {
            const offset = PLAYER_RADIUS + BALL_RADIUS;
            let ballX = x + dirX * offset;
            let ballY = y + dirY * offset;

            ballX = Math.max(BALL_RADIUS, Math.min(pitchRect.width - BALL_RADIUS, ballX));
            ballY = Math.max(BALL_RADIUS, Math.min(pitchRect.height - BALL_RADIUS, ballY));

            ballEl.style.left = (ballX - BALL_RADIUS) + "px";
            ballEl.style.top = (ballY - BALL_RADIUS) + "px";

            const bState = ballsState[0];
            if (bState) {
              bState.xRel = ballX / pitchRect.width;
              bState.yRel = ballY / pitchRect.height;
            }

            addBallTrailPoint(ballX, ballY);
          }
        }

        dragInfo.prevX = x;
        dragInfo.prevY = y;

        if (recordingActorId === id && recordingSequence) {
          addRecordingPoint(x, y);
        }

      } else if (dragInfo.type === "goal") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + el.offsetWidth / 2;
        let y = e.clientY - pitchRect.top - offsetY + el.offsetHeight / 2;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        el.style.left = x + "px";
        el.style.top = y + "px";

        const gState = goalsState.find(g => g.id === id);
        if (gState) {
          gState.xRel = x / pitchRect.width;
          gState.yRel = y / pitchRect.height;
        }

      } else if (dragInfo.type === "cone") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + el.offsetWidth / 2;
        let y = e.clientY - pitchRect.top - offsetY + el.offsetHeight / 2;

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        el.style.left = (x - el.offsetWidth / 2) + "px";
        el.style.top = (y - el.offsetHeight / 2) + "px";

        const cState = conesState.find(c => c.id === id);
        if (cState) {
          cState.xRel = x / pitchRect.width;
          cState.yRel = y / pitchRect.height;
        }

      } else if (dragInfo.type === "ball") {
        const { el, offsetX, offsetY, pitchRect, id } = dragInfo;

        let x = e.clientX - pitchRect.left - offsetX + BALL_RADIUS;
        let y = e.clientY - pitchRect.top - offsetY + BALL_RADIUS;

        x = Math.max(BALL_RADIUS, Math.min(pitchRect.width - BALL_RADIUS, x));
        y = Math.max(BALL_RADIUS, Math.min(pitchRect.height - BALL_RADIUS, y));

        el.style.left = (x - BALL_RADIUS) + "px";
        el.style.top = (y - BALL_RADIUS) + "px";

        const bState = ballsState.find(b => b.id === id);
        if (bState) {
          bState.xRel = x / pitchRect.width;
          bState.yRel = y / pitchRect.height;
        }

        addBallTrailPoint(x, y);

      } else if (dragInfo.type === "resize") {
        const { startY, startHeight } = dragInfo;
        const dy = e.clientY - startY;
        let newHeight = startHeight + dy;

        const minHeight = 200;
        const maxHeight = window.innerHeight - 150;

        newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
        pitch.style.height = newHeight + "px";

        updateRatioDisplay();
        renderMidline();
        renderCenterCircle();

      } else if (dragInfo.type === "midline") {
        const { startY, startRel, pitchRect } = dragInfo;
        const dy = e.clientY - startY;
        const newRel = Math.max(0, Math.min(1, startRel + dy / pitchRect.height));
        midlineYRel = newRel;
        renderMidline();
        renderCenterCircle();
      }

      // Logga frame för global inspelning
      sampleFrame();
    }

    function onPointerUp(e) {
      if (!dragInfo) return;

      if (dragInfo.type === "player") {
        const { pitchRect, id, el } = dragInfo;
        el.classList.remove("dragging");
        el.releasePointerCapture(e.pointerId);

        stopRecording();

        resolveOverlapsForPlayer(id, pitchRect);

        const ballEl = pitch.querySelector(".ball");
        if (ballEl) {
          const ballRect = ballEl.getBoundingClientRect();
          const playerRect = el.getBoundingClientRect();
          const pRect = pitch.getBoundingClientRect();

          const px = playerRect.left - pRect.left + PLAYER_RADIUS;
          const py = playerRect.top - pRect.top + PLAYER_RADIUS;
          const bx = ballRect.left - pRect.left + BALL_RADIUS;
          const by = ballRect.top - pRect.top + BALL_RADIUS;

          const dist = Math.hypot(px - bx, py - by);
          if (dist < PLAYER_RADIUS + BALL_RADIUS + 2) {
            ballOwnerId = id;

            // här låter vi bollen ligga kvar där den kolliderade;
            // ingen tvingad "uppåt"-flytt längre
          }
        }

      } else if (dragInfo.type === "goal" || dragInfo.type === "cone" || dragInfo.type === "ball") {
        dragInfo.el.classList.remove("dragging");
        dragInfo.el.releasePointerCapture(e.pointerId);
      } else if (dragInfo.type === "resize") {
        resizeHandle.releasePointerCapture(e.pointerId);
      } else if (dragInfo.type === "midline") {
        midlineEl.releasePointerCapture(e.pointerId);
      }

      dragInfo = null;
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
    }

    function resolveOverlapsForPlayer(id, pitchRect) {
      const playerEl = [...pitch.querySelectorAll(".player")].find(el => el.dataset.id === id);
      if (!playerEl) return;

      let x = parseFloat(playerEl.style.left) + PLAYER_RADIUS;
      let y = parseFloat(playerEl.style.top) + PLAYER_RADIUS;

      for (let step = 0; step < MAX_RELAX_STEPS; step++) {
        let moved = false;

        const others = playersState.filter(p => p.id !== id);
        for (const other of others) {
          const ox = other.xRel * pitchRect.width;
          const oy = other.yRel * pitchRect.height;

          const dx = x - ox;
          const dy = y - oy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < MIN_DIST && dist > 0) {
            const overlap = MIN_DIST - dist;
            const nx = dx / dist;
            const ny = dy / dist;

            x += nx * overlap * 0.6;
            y += ny * overlap * 0.6;

            moved = true;
          }
        }

        x = Math.max(0, Math.min(pitchRect.width, x));
        y = Math.max(0, Math.min(pitchRect.height, y));

        if (!moved) break;
      }

      playerEl.style.left = (x - PLAYER_RADIUS) + "px";
      playerEl.style.top = (y - PLAYER_RADIUS) + "px";

      const pState = playersState.find(p => p.id === id);
      if (pState) {
        pState.xRel = x / pitchRect.width;
        pState.yRel = y / pitchRect.height;
      }
    }

    function renderGoals() {
      [...pitch.querySelectorAll(".goal")].forEach(el => el.remove());

      const pitchRect = pitch.getBoundingClientRect();

      for (const g of goalsState) {
        const el = document.createElement("div");
        el.className = "goal";
        el.dataset.id = g.id;

        const label = document.createElement("span");
        label.className = "goal-label";
        label.textContent = "Mål";
        el.appendChild(label);

        const x = g.xRel * pitchRect.width;
        const y = g.yRel * pitchRect.height;

        el.style.left = x + "px";
        el.style.top = y + "px";
        el.style.transform = `translate(-50%, -50%) rotate(${g.rotationDeg}deg)`;

        pitch.appendChild(el);
        setupGoalDrag(el);
      }
    }

    function renderCones() {
      [...pitch.querySelectorAll(".cone")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const c of conesState) {
        const el = document.createElement("div");
        el.className = "cone";
        el.dataset.id = c.id;

        const x = c.xRel * pitchRect.width;
        const y = c.yRel * pitchRect.height;

        const halfW = el.offsetWidth / 2 || 11;
        const halfH = el.offsetHeight / 2 || 11;

        el.style.left = (x - halfW) + "px";
        el.style.top = (y - halfH) + "px";

        pitch.appendChild(el);
        setupConeDrag(el);
      }
    }

    function renderBalls() {
      [...pitch.querySelectorAll(".ball")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const b of ballsState) {
        const el = document.createElement("div");
        el.className = "ball";
        el.dataset.id = b.id;

        const x = b.xRel * pitchRect.width;
        const y = b.yRel * pitchRect.height;

        const halfW = el.offsetWidth / 2 || 11;
        const halfH = el.offsetHeight / 2 || 11;

        el.style.left = (x - halfW) + "px";
        el.style.top = (y - halfH) + "px";

        pitch.appendChild(el);
        setupBallDrag(el);
      }
    }

    function renderAllSequencesPaths() {
      [...overlaySvg.querySelectorAll(".run-path")].forEach(el => el.remove());
      const pitchRect = pitch.getBoundingClientRect();

      for (const seq of drillSequences) {
        if (!seq.points || !seq.points.length) continue;
        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("id", seq.svgId);
        polyline.setAttribute("class", "run-path");
        const pts = seq.points
          .map(p => (p.xRel * pitchRect.width) + "," + (p.yRel * pitchRect.height))
          .join(" ");
        polyline.setAttribute("points", pts);
        overlaySvg.appendChild(polyline);
      }
    }

    function renderMidline() {
      const rect = pitch.getBoundingClientRect();
      const y = rect.height * midlineYRel;
      midlineEl.style.top = y + "px";
    }

    function renderCenterCircle() {
      const rect = pitch.getBoundingClientRect();
      const r = rect.width * centerCircleRadiusRel;
      const cx = rect.width / 2;
      const cy = rect.height * midlineYRel;
      centerCircleEl.style.width = (2 * r) + "px";
      centerCircleEl.style.height = (2 * r) + "px";
      centerCircleEl.style.left = (cx - r) + "px";
      centerCircleEl.style.top = (cy - r) + "px";
    }

    // (Playback-loopen lämnas som tidigare tills vi byter till nya recordings)

    playAllBtn.addEventListener("click", () => {
      if (!drillSequences.length) return;
      isPlaying = true;
      playbackStartTime = performance.now();
      // playbackLoop();  // gamla spelare-sekvensen används tills vi byter logik
    });

    stopPlayBtn.addEventListener("click", () => {
      isPlaying = false;
      if (playbackRequestId) cancelAnimationFrame(playbackRequestId);
    });

    recordToggleBtn.addEventListener("click", () => {
      recordMode = !recordMode;
      recordToggleBtn.classList.toggle("selected", recordMode);

      if (recordMode) {
        // starta ny global recording också
        currentRecording = {
          id: "REC" + (recordings.length + 1),
          step: currentStep,
          startTime: performance.now(),
          frames: []
        };
      } else {
        if (currentRecording) {
          recordings.push(currentRecording);
          currentRecording = null;
          console.log("Recordings:", recordings);
        }
      }
    });

    // UI-kontroller
    resizeHandle.addEventListener("pointerdown", (e) => {
      const rect = pitch.getBoundingClientRect();
      resizeHandle.setPointerCapture(e.pointerId);
      dragInfo = {
        type: "resize",
        startY: e.clientY,
        startHeight: rect.height
      };
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    });

    undoBtn.addEventListener("click", () => {
      if (!undoStack.length) return;
      const snapshot = undoStack.pop();
      restoreStateFromSnapshot(snapshot);
    });

    showLinesCheckbox.addEventListener("change", () => {
      applyLinesClass();
    });

    moveMidlineBtn.addEventListener("click", () => {
      midlineMoveMode = !midlineMoveMode;
      moveMidlineBtn.classList.toggle("selected", midlineMoveMode);
    });

    midlineEl.addEventListener("pointerdown", (e) => {
      if (!midlineMoveMode) return;
      const rect = pitch.getBoundingClientRect();
      midlineEl.setPointerCapture(e.pointerId);
      dragInfo = {
        type: "midline",
        startY: e.clientY,
        startRel: midlineYRel,
        pitchRect: rect
      };
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    });

    circleMinusBtn.addEventListener("click", () => {
      centerCircleRadiusRel = Math.max(0.05, centerCircleRadiusRel - 0.02);
      renderCenterCircle();
    });

    circlePlusBtn.addEventListener("click", () => {
      centerCircleRadiusRel = Math.min(0.3, centerCircleRadiusRel + 0.02);
      renderCenterCircle();
    });

    setupConeDrag(coneSource);
    setupBallDrag(ballSource);
    setupPlayerSourceDrag(playerBlueSource, "blue");
    setupPlayerSourceDrag(playerRedSource, "red");
    setupGoalSourceDrag(goalSource);

    pitch.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    window.addEventListener("load", () => {
      setTimeout(() => {
        fitPitchHeight();
        updateRatioDisplay();
        applyLinesClass();
        renderMidline();
        renderCenterCircle();
      }, 100);
    });

    window.addEventListener("resize", () => {
      fitPitchHeight();
      updateRatioDisplay();
      renderGoals();
      renderCones();
      renderBalls();
      renderAllSequencesPaths();
      renderBallTrail();
      renderMidline();
      renderCenterCircle();
    });
  </script>
</body>
</html>
